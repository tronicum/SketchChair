<script type="text/javascript" src="jshashtable-2.1.js"></script>
<script type="text/javascript" src="toxiclibs.js"></script>
<script type="text/javascript" src="processing-1.3.6.js"></script>

<script type="text/javascript">
<!--
var mySketch = new Processing.Sketch(function($p) {
	
	
	
	
	
	
	
	
		var Vec2D = (function() {
		function Vec2D() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$this_1.x = 0;
		$this_1.y = 0;
		//$this_1.X_AXIS =  new Vec2D(1, 0);
		//$this_1.Y_AXIS =  new Vec2D(0, 1);
		$p.addMethod($this_1, 'fromTheta', fromTheta$1);
		function add$2(a, b) {
		return new Vec2D($this_1.x + a, $this_1.y + b);
		}
		$p.addMethod($this_1, 'add', add$2);
		function add$1_2(v) {
		return new Vec2D($this_1.x + v.x, $this_1.y + v.y);
		}
		$p.addMethod($this_1, 'add', add$1_2);
		function addSelf$2(a, b) {
		$this_1.x += a;
		$this_1.y += b;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'addSelf', addSelf$2);
		function addSelf$1_2(v) {
		$this_1.x += v.x;
		$this_1.y += v.y;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'addSelf', addSelf$1_2);
		function angleBetween$1(v) {
		return  Math.acos($this_1.$self.dot(v));
		}
		$p.addMethod($this_1, 'angleBetween', angleBetween$1);
		function angleBetween$2_2(v, forceNormalize) {
		var theta = 0;
		if (forceNormalize) {
		theta = $this_1.$self.getNormalized().dot(v.getNormalized());
		} else {
		theta = $this_1.$self.dot(v);
		}
		return  Math.acos(theta);
		}
		$p.addMethod($this_1, 'angleBetween', angleBetween$2_2);
		function clear$0() {
		$this_1.x = $this_1.y = 0;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'clear', clear$0);
		function closestPointOnLine$2(a, b) {
		var v =  b.sub(a);
		var t =  $this_1.$self.sub(a).dot(v) / v.magSquared();
		 if (t < 0.0) {
		return a;
		}
		if (t > 1.0) {
		return b;
		}
		 return a.add(v.scaleSelf(t));
		}
		$p.addMethod($this_1, 'closestPointOnLine', closestPointOnLine$2);
		function closestPointOnTriangle$3(a, b, c) {
		var Rab =  $this_1.$self.closestPointOnLine(a, b);
		var Rbc =  $this_1.$self.closestPointOnLine(b, c);
		var Rca =  $this_1.$self.closestPointOnLine(c, a);

		var dAB =  $this_1.$self.sub(Rab).magnitude();
		var dBC =  $this_1.$self.sub(Rbc).magnitude();
		var dCA =  $this_1.$self.sub(Rca).magnitude();

		var min =  dAB;
		var result =  Rab;

		if (dBC < min) {
		min = dBC;
		result = Rbc;
		}
		if (dCA < min) {
		result = Rca;
		}

		return result;
		}
		$p.addMethod($this_1, 'closestPointOnTriangle', closestPointOnTriangle$3);
		function compareTo$1(v) {
		if ($this_1.x == v.x && $this_1.y == v.y) {
		return 0;
		}
		return  $p.__int_cast(($this_1.$self.magSquared() - v.magSquared()));
		}
		$p.addMethod($this_1, 'compareTo', compareTo$1);
		function copy$0() {
		return new Vec2D($this_1.$self);
		}
		$p.addMethod($this_1, 'copy', copy$0);
		function cross$1(v) {
		return ($this_1.x * v.y) - ($this_1.y * v.x);
		}
		$p.addMethod($this_1, 'cross', cross$1);
		function distanceTo$1(v) {
		if (v != null) {
		var dx =  $this_1.x - v.x;
		var dy =  $this_1.y - v.y;
		return  Math.sqrt(dx * dx + dy * dy);
		} else {
		return 0;
		}
		}
		$p.addMethod($this_1, 'distanceTo', distanceTo$1);
		function distanceToSquared$1(v) {
		if (v != null) {
		var dx =  $this_1.x - v.x;
		var dy =  $this_1.y - v.y;
		return dx * dx + dy * dy;
		} else {
		return 0;
		}
		}
		$p.addMethod($this_1, 'distanceToSquared', distanceToSquared$1);
		function dot$1(v) {
		return $this_1.x * v.x + $this_1.y * v.y;
		}
		$p.addMethod($this_1, 'dot', dot$1);
		function equals$1(obj) {
		if ($p.__instanceof(obj , Vec2D)) {
		var v =   obj;
		return $this_1.x == v.x && $this_1.y == v.y;
		}

		return false;
		}
		$p.addMethod($this_1, 'equals', equals$1);
		function getComponent$1(id) {
		switch (id) {
		case $p.X:
		return $this_1.x;case $p.Y:
		return $this_1.y;
		}
		return 0;
		}
		$p.addMethod($this_1, 'getComponent', getComponent$1);
		function getInverted$0() {
		return new Vec2D(-$this_1.x, -$this_1.y);
		}
		$p.addMethod($this_1, 'getInverted', getInverted$0);
		function getLimited$1(lim) {
		if ($this_1.$self.magSquared() > lim * lim) {
		return $this_1.$self.getNormalized().scaleSelf(lim);
		}
		return new Vec2D($this_1.$self);
		}
		$p.addMethod($this_1, 'getLimited', getLimited$1);
		function getNormalized$0() {
		return new Vec2D($this_1.$self).normalize();
		}
		$p.addMethod($this_1, 'getNormalized', getNormalized$0);
		function getNormalizedTo$1(len) {
		return $this_1.$self.getNormalized().scaleSelf(len);
		}
		$p.addMethod($this_1, 'getNormalizedTo', getNormalizedTo$1);
		function getPerpendicular$0() {
		return new Vec2D($this_1.$self).perpendicular();
		}
		$p.addMethod($this_1, 'getPerpendicular', getPerpendicular$0);
		function getReciprocal$0() {
		return $this_1.$self.copy().reciprocal();
		}
		$p.addMethod($this_1, 'getReciprocal', getReciprocal$0);
		function getRotated$1(theta) {
			var v = new Vec2D($this_1.$self);
			v.rotate(theta);
			return v;
		}
		$p.addMethod($this_1, 'getRotated', getRotated$1);
		function getSignum$0() {
		return new Vec2D($this_1.$self).signum();
		}
		$p.addMethod($this_1, 'getSignum', getSignum$0);
		function heading$0() {
		return  Math.atan2($this_1.y, $this_1.x);
		}
		$p.addMethod($this_1, 'heading', heading$0);
		function interpolateTo$2(v, f) {
		return new Vec2D($this_1.x + (v.x - $this_1.x) * f, $this_1.y + (v.y - $this_1.y) * f);
		}
		$p.addMethod($this_1, 'interpolateTo', interpolateTo$2);
		function interpolateToSelf$2(v, f) {
		$this_1.x += (v.x - $this_1.x) * f;
		$this_1.y += (v.y - $this_1.y) * f;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'interpolateToSelf', interpolateToSelf$2);
		function intersectRayCircle$3(rayDir, circleOrigin, circleRadius) {
		var q =  circleOrigin.sub($this_1.$self);
		var distSquared =  q.magSquared();
		var v =  q.dot(rayDir);
		var d =  circleRadius * circleRadius - (distSquared - v * v);

		 if (d < 0.0) {
		return -1;
		}

		 return v -  Math.sqrt(d);
		}
		$p.addMethod($this_1, 'intersectRayCircle', intersectRayCircle$3);
		function invert$0() {
		$this_1.x *= -1;
		$this_1.y *= -1;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'invert', invert$0);
		function isInCircle$2(sO, sR) {
		var d =  $this_1.$self.sub(sO).magSquared();
		return (d <= sR * sR);
		}
		$p.addMethod($this_1, 'isInCircle', isInCircle$2);
		function isZeroVector$0() {
		return $this_1.x == 0 && $this_1.y == 0;
		}
		$p.addMethod($this_1, 'isZeroVector', isZeroVector$0);
		function limit$1(lim) {
		if ($this_1.$self.magSquared() > lim * lim) {
		return $this_1.$self.normalize().scaleSelf(lim);
		}
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'limit', limit$1);
		function magnitude$0() {
		return  Math.sqrt($this_1.x * $this_1.x + $this_1.y * $this_1.y);
		}
		$p.addMethod($this_1, 'magnitude', magnitude$0);
		function magSquared$0() {
		return $this_1.x * $this_1.x + $this_1.y * $this_1.y;
		}
		$p.addMethod($this_1, 'magSquared', magSquared$0);
		function normalize$0() {
		var mag =  $this_1.x * $this_1.x + $this_1.y * $this_1.y;
		if (mag > 0) {
		mag = 1 /  Math.sqrt(mag);
		$this_1.x *= mag;
		$this_1.y *= mag;
		}
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'normalize', normalize$0);
		function normalizeTo$1(len) {
		return $this_1.$self.normalize().scaleSelf(len);
		}
		$p.addMethod($this_1, 'normalizeTo', normalizeTo$1);
		function perpendicular$0() {
		var t =  $this_1.x;
		$this_1.x = -$this_1.y;
		$this_1.y = t;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'perpendicular', perpendicular$0);
		function reciprocal$0() {
		$this_1.x = 1 / $this_1.x;
		$this_1.y = 1 / $this_1.y;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'reciprocal', reciprocal$0);
		function rotate$1(theta) {
		var co =   Math.cos(theta);
		var si =   Math.sin(theta);
		
		var xx =  co * $this_1.x - si * $this_1.y;
		$this_1.y = si * $this_1.x + co * $this_1.y;
		$this_1.x = xx;
		
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'rotate', rotate$1);
		function scale$1(s) {
		return new Vec2D($this_1.x * s, $this_1.y * s);
		}
		$p.addMethod($this_1, 'scale', scale$1);
		function scale$2_2(a, b) {
		return new Vec2D($this_1.x * a, $this_1.y * b);
		}
		$p.addMethod($this_1, 'scale', scale$2_2);
		function scale$1_3(s) {
		return new Vec2D($this_1.x * s.x, $this_1.y * s.y);
		}
		$p.addMethod($this_1, 'scale', scale$1_3);
		function scaleSelf$1(s) {
		$this_1.x *= s;
		$this_1.y *= s;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'scaleSelf', scaleSelf$1);
		function scaleSelf$2_2(a, b) {
		$this_1.x *= a;
		$this_1.y *= b;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'scaleSelf', scaleSelf$2_2);
		function scaleSelf$1_3(s) {
			//console.log("here");

		$this_1.x *= s;
		$this_1.y *= s;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'scaleSelf', scaleSelf$1_3);
		function set$2(x, y) {
		$this_1.x = x;
		$this_1.y = y;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'set', set$2);
		function set$1_2(v) {
		$this_1.x = v.x;
		$this_1.y = v.y;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'set', set$1_2);
		function setComponent$2(id, val) {
		switch (id) {
		case $p.X:
		$this_1.x = val;
		break;case $p.Y:
		$this_1.y = val;
		break;
		}
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'setComponent', setComponent$2);
		function signum$0() {
		$this_1.x = ($this_1.x < 0 ? -1 : $this_1.x == 0 ? 0 : 1);
		$this_1.y = ($this_1.y < 0 ? -1 : $this_1.y == 0 ? 0 : 1);
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'signum', signum$0);
		function sub$2(a, b) {
		return new Vec2D($this_1.x - a, $this_1.y - b);
		}
		$p.addMethod($this_1, 'sub', sub$2);
		function sub$1_2(v) {
		return new Vec2D($this_1.x - v.x, $this_1.y - v.y);
		}
		$p.addMethod($this_1, 'sub', sub$1_2);
		function subSelf$2(a, b) {
		$this_1.x -= a;
		$this_1.y -= b;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'subSelf', subSelf$2);
		function subSelf$1_2(v) {
		$this_1.x -= v.x;
		$this_1.y -= v.y;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'subSelf', subSelf$1_2);
		function tangentNormalOfEllipse$2(eO, eR) {
		var p =  $this_1.$self.sub(eO);

		var xr2 =  eR.x * eR.x;
		var yr2 =  eR.y * eR.y;

		return new Vec2D(p.x / xr2, p.y / yr2).normalize();
		}
		$p.addMethod($this_1, 'tangentNormalOfEllipse', tangentNormalOfEllipse$2);
		function toArray$0() {
		return [ $this_1.x, $this_1.y ];
		}
		$p.addMethod($this_1, 'toArray', toArray$0);
		function toCartesian$0() {
		var xx =   ($this_1.x * Math.cos($this_1.y));
		$this_1.y =  ($this_1.x * Math.sin($this_1.y));
		$this_1.x = xx;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'toCartesian', toCartesian$0);
		function toPolar$0() {
		var r =   Math.sqrt($this_1.x * $this_1.x + $this_1.y * $this_1.y);
		$this_1.y =  Math.atan2($this_1.y, $this_1.x);
		$this_1.x = r;
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'toPolar', toPolar$0);
		function toString$0_NaN() {
		var sb =  new StringBuffer(32);
		sb.append("{x:").append($this_1.x).append(", y:").append($this_1.y).append("}");
		return sb.toString();
		}
		$p.addMethod($this_1, 'toString', toString$0_NaN);
		function $constr_0(){
		$superCstr();

		$this_1.x = 0;
		$this_1.y = 0;
		}

		function $constr_2(x, y){
		$superCstr();

		$this_1.x = x;
		$this_1.y = y;
		}

		function $constr_1(v){
		$superCstr();

		$this_1.$self.set(v);
		}

		function $constr() {
		if(arguments.length === 0) { $constr_0.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		function fromTheta$1(theta) {
		return new Vec2D( Math.cos(theta),  Math.sin(theta));
		}
		$p.addMethod(Vec2D, 'fromTheta', fromTheta$1);
		return Vec2D;
		})();
		$p.Vec2D = Vec2D;
		var SketchShape = (function() {
		function SketchShape() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$p.defineProperty($this_1, 'TYPE_PATH', {get: function(){return SketchShape.TYPE_PATH}, set: function(val){SketchShape.TYPE_PATH = val}});
		$p.defineProperty($this_1, 'TYPE_SPLINE', {get: function(){return SketchShape.TYPE_SPLINE}, set: function(val){SketchShape.TYPE_SPLINE = val}});
		$p.defineProperty($this_1, 'OFFSET_SPLINE', {get: function(){return SketchShape.OFFSET_SPLINE}, set: function(val){SketchShape.OFFSET_SPLINE = val}});
		$p.defineProperty($this_1, 'UNION_ADD', {get: function(){return SketchShape.UNION_ADD}, set: function(val){SketchShape.UNION_ADD = val}});
		$p.defineProperty($this_1, 'UNION_SUBTRACT', {get: function(){return SketchShape.UNION_SUBTRACT}, set: function(val){SketchShape.UNION_SUBTRACT = val}});
		$this_1.selectedNodes =  new $p.ArrayList();
		$this_1.type =  0;
		$this_1.destroy =  false;
		$this_1.selected =  false;
		$this_1.editable =  true;
		$this_1.isSelectedShape =  false;
		$this_1.id =  0;
		$this_1.lastMouseOverPercent =  0.0;
		$this_1.lastMouseOverVec = null;
		$this_1.parentSketch = null;
		$this_1.closed =  false;
		$this_1.union =  SketchShape.UNION_ADD;
		$this_1.isConstructionLine =  false;
		$this_1.debugPercent =  0;
		function add$1(point) {

		}
		$p.addMethod($this_1, 'add', add$1);
		function build$0() {

		}
		$p.addMethod($this_1, 'build', build$0);
		function clone$0() {

		}
		$p.addMethod($this_1, 'clone', clone$0);
		function copy$1(parentSketch) {

		}
		$p.addMethod($this_1, 'copy', copy$1);
		function countSelectedNodes$0() {
		return $this_1.$self.getSelectedNodes().size();
		}
		$p.addMethod($this_1, 'countSelectedNodes', countSelectedNodes$0);
		function destroy$0() {

		}
		$p.addMethod($this_1, 'destroy', destroy$0);
		function flipHorizontal$1(centre) {

		}
		$p.addMethod($this_1, 'flipHorizontal', flipHorizontal$1);
		function get$1(i) {
		return null;
		}
		$p.addMethod($this_1, 'get', get$1);
		function getClosed$0() {
		return $this_1.closed;
		}
		$p.addMethod($this_1, 'getClosed', getClosed$0);
		function getClosestPercent$2(mouseX, mouseY) {

		}
		$p.addMethod($this_1, 'getClosestPercent', getClosestPercent$2);
		function getClosestPoint$1(pointOnPlan) {

		}
		$p.addMethod($this_1, 'getClosestPoint', getClosestPoint$1);
		function getClosestPoint$1_2(pointOnPlan) {

		}
		$p.addMethod($this_1, 'getClosestPoint', getClosestPoint$1_2);
		function getClosestPointAlongPath$2(x, y) {

		}
		$p.addMethod($this_1, 'getClosestPointAlongPath', getClosestPointAlongPath$2);
		function getId$0() {
		return $this_1.id;
		}
		$p.addMethod($this_1, 'getId', getId$0);
		function getLast$0() {

		}
		$p.addMethod($this_1, 'getLast', getLast$0);
		function getlength$0() {
		return 0;
		}
		$p.addMethod($this_1, 'getlength', getlength$0);
		function getLength$0() {

		}
		$p.addMethod($this_1, 'getLength', getLength$0);
		function getlengthPerPercent$0() {
		return 0;
		}
		$p.addMethod($this_1, 'getlengthPerPercent', getlengthPerPercent$0);
		function getOutlineGeneralPath$0() {

		}
		$p.addMethod($this_1, 'getOutlineGeneralPath', getOutlineGeneralPath$0);
		function getOverShape$2(x, y) {

		}
		$p.addMethod($this_1, 'getOverShape', getOverShape$2);
		function getParentSketch$0() {
		return $this_1.parentSketch;
		}
		$p.addMethod($this_1, 'getParentSketch', getParentSketch$0);
		function getPath$0() {

		}
		$p.addMethod($this_1, 'getPath', getPath$0);
		function getPerpendicular$1(i) {

		}
		$p.addMethod($this_1, 'getPerpendicular', getPerpendicular$1);
		function getPos$1(i) {

		}
		$p.addMethod($this_1, 'getPos', getPos$1);
		function getSelectedNodes$0() {
		return $this_1.selectedNodes;
		}
		$p.addMethod($this_1, 'getSelectedNodes', getSelectedNodes$0);
		function getSketchPointpickBuffer$1(col) {

		}
		$p.addMethod($this_1, 'getSketchPointpickBuffer', getSketchPointpickBuffer$1);
		function getType$0() {
		return $this_1.type;
		}
		$p.addMethod($this_1, 'getType', getType$0);
		function getVec2DpickBuffer$1(col) {

		}
		$p.addMethod($this_1, 'getVec2DpickBuffer', getVec2DpickBuffer$1);
		function insertPoint$1(closestPoint) {

		}
		$p.addMethod($this_1, 'insertPoint', insertPoint$1);
		function isConstructionLine$0() {
		return $this_1.isConstructionLine;
		}
		$p.addMethod($this_1, 'isConstructionLine', isConstructionLine$0);
		function isDestroying$0() {
		return $this_1.destroy;
		}
		$p.addMethod($this_1, 'isDestroying', isDestroying$0);
		function isPointInside$1(p) {

		}
		$p.addMethod($this_1, 'isPointInside', isPointInside$1);
		function mouseDragged$2(mouseX, mouseY) {

		}
		$p.addMethod($this_1, 'mouseDragged', mouseDragged$2);
		function mouseReleased$2(mouseX, mouseY) {

		}
		$p.addMethod($this_1, 'mouseReleased', mouseReleased$2);
		function movePoint$2(selectedVec, planePoint) {

		}
		$p.addMethod($this_1, 'movePoint', movePoint$2);
		function offset$0() {

		}
		$p.addMethod($this_1, 'offset', offset$0);
		function optimize$0() {

		}
		$p.addMethod($this_1, 'optimize', optimize$0);
		function overlaps$1(curSketch) {
		var path1 =  $this_1.$self.getPath();
		var path2 =  curSketch.getPath();
		return path1.intersects(path2);
		}
		$p.addMethod($this_1, 'overlaps', overlaps$1);
		function removeVertex$1(v) {

		}
		$p.addMethod($this_1, 'removeVertex', removeVertex$1);
		function render$1(g) {

		}
		$p.addMethod($this_1, 'render', render$1);
		function renderPickBuffer$1(g) {

		}
		$p.addMethod($this_1, 'renderPickBuffer', renderPickBuffer$1);
		function renderSilhouette$1(g) {

		}
		$p.addMethod($this_1, 'renderSilhouette', renderSilhouette$1);
		function replace$1(objClone) {

		}
		$p.addMethod($this_1, 'replace', replace$1);
		function scale$2(scale, centre) {

		}
		$p.addMethod($this_1, 'scale', scale$2);
		function select$0() {

		}
		$p.addMethod($this_1, 'select', select$0);
		function selectNodes$2(x, y) {

		}
		$p.addMethod($this_1, 'selectNodes', selectNodes$2);
		function setClosed$1(flag) {
		$this_1.closed = flag;
		}
		$p.addMethod($this_1, 'setClosed', setClosed$1);
		function setDestroy$1(destroy) {
		$this_1.destroy = destroy;
		}
		$p.addMethod($this_1, 'setDestroy', setDestroy$1);
		function setId$1(id) {
		$this_1.id = id;
		}
		$p.addMethod($this_1, 'setId', setId$1);
		function setIsContructionLine$1(construction) {
		$this_1.isConstructionLine = construction;
		}
		$p.addMethod($this_1, 'setIsContructionLine', setIsContructionLine$1);
		function setParentSketch$1(sketch) {
		$this_1.parentSketch = sketch;
		}
		$p.addMethod($this_1, 'setParentSketch', setParentSketch$1);
		function setSelectedNodes$1(selectedNodes) {
		$this_1.selectedNodes = selectedNodes;
		}
		$p.addMethod($this_1, 'setSelectedNodes', setSelectedNodes$1);
		function setSketchPointpickBuffer$5(col, selectedVec, selectedShape, selectedVecPlane, isSelectedVecOnOutline) {
		return null;
		}
		$p.addMethod($this_1, 'setSketchPointpickBuffer', setSketchPointpickBuffer$5);
		function setType$1(type) {
		$this_1.type = type;
		}
		$p.addMethod($this_1, 'setType', setType$1);
		function setVec2DpickBuffer$5(col, selectedVec, selectedShape, selectedVecPlane, isSelectedVecOnOutline) {

		}
		$p.addMethod($this_1, 'setVec2DpickBuffer', setVec2DpickBuffer$5);
		function size$0() {
		return 0;
		}
		$p.addMethod($this_1, 'size', size$0);
		function toXML$0() {

		}
		$p.addMethod($this_1, 'toXML', toXML$0);
		function unselect$0() {

		}
		$p.addMethod($this_1, 'unselect', unselect$0);
		function unselectNodes$0() {
		$this_1.$self.getSelectedNodes().clear();
		}
		$p.addMethod($this_1, 'unselectNodes', unselectNodes$0);
		function setEditable$1(editable_in) {
		$this_1.editable = editable_in;
		}
		$p.addMethod($this_1, 'setEditable', setEditable$1);
		function $constr_1(parentSketch){
		$superCstr();

		$this_1.$self.setParentSketch(parentSketch);

		if ($this_1.$self.getParentSketch() != null
		&& $this_1.$self.getParentSketch().getSketchGlobals() != null)
		$this_1.id = $this_1.$self.getParentSketch().getSketchGlobals().sketch_id++;
		}

		function $constr() {
		if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		SketchShape.TYPE_PATH =  2;
		SketchShape.TYPE_SPLINE =  3;
		SketchShape.OFFSET_SPLINE =  4;
		SketchShape.UNION_ADD =  0;
		SketchShape.UNION_SUBTRACT =  1;
		return SketchShape;
		})();
		$p.SketchShape = SketchShape;
		var Sketch = (function() {
		function Sketch() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES', {get: function(){return Sketch.RENDER_3D_EDITING_PLANES}, set: function(val){Sketch.RENDER_3D_EDITING_PLANES = val}});
		$p.defineProperty($this_1, 'RENDER_3D_PREVIW', {get: function(){return Sketch.RENDER_3D_PREVIW}, set: function(val){Sketch.RENDER_3D_PREVIW = val}});
		$p.defineProperty($this_1, 'RENDER_3D_DIAGRAM', {get: function(){return Sketch.RENDER_3D_DIAGRAM}, set: function(val){Sketch.RENDER_3D_DIAGRAM = val}});
		$p.defineProperty($this_1, 'RENDER_EDIT_SELECT', {get: function(){return Sketch.RENDER_EDIT_SELECT}, set: function(val){Sketch.RENDER_EDIT_SELECT = val}});
		$p.defineProperty($this_1, 'RENDER_3D_NORMAL', {get: function(){return Sketch.RENDER_3D_NORMAL}, set: function(val){Sketch.RENDER_3D_NORMAL = val}});
		$this_1.sketchShapes = null;
		$this_1.selected =  true;
		$this_1.sketchTools = null;
		$this_1.sketchGlobals = null;
		$this_1.onSlicePlane = null;
		$this_1.screenshot =  false;
		$this_1.sketch_id = 0;
		$this_1.selectedNodes =  new $p.ArrayList();
		$this_1.layerSelected =  true;
		$this_1.renderMode = 0;
		$this_1.render3D = false;
		function add$1(sketchShape) {
		$this_1.sketchShapes.add(sketchShape);
		}
		$p.addMethod($this_1, 'add', add$1);
		function addPointAlongPath$2(x, y) {
		return $this_1.sketchShapes.addPointAlongPath(x, y);
		}
		$p.addMethod($this_1, 'addPointAlongPath', addPointAlongPath$2);
		function build$0() {
		for (var i =  0;  i < $this_1.$self.getSketchShapes().l.size();  i++) {
		var s =  $this_1.$self.getSketchShapes().l.get(i);
		s.build();
		}
		$this_1.$self.buildOutline();
		}
		$p.addMethod($this_1, 'build', build$0);
		function buildOutline$0() {
		$this_1.sketchShapes.buildOutline(false, false);
		}
		$p.addMethod($this_1, 'buildOutline', buildOutline$0);
		function buildOutline$2_2(addSlots, booleanSlots) {
		$this_1.sketchShapes.buildOutline(addSlots, booleanSlots);
		}
		$p.addMethod($this_1, 'buildOutline', buildOutline$2_2);
		function clone$0() {
		var s =  new Sketch($this_1.$self.getSketchTools(), $this_1.$self.getSketchGlobals());
		s.sketchShapes = $this_1.sketchShapes.clone();
		s.sketchShapes.setParentSketch(s);

		return s;
		}
		$p.addMethod($this_1, 'clone', clone$0);
		function contains$1(path) {
		return $p.__contains($this_1.sketchShapes,path);
		}
		$p.addMethod($this_1, 'contains', contains$1);
		function copy$0() {
		var newSketch =  new Sketch($this_1.$self.getSketchTools(),
		$this_1.$self.getSketchGlobals());
		newSketch.sketchShapes = $this_1.sketchShapes.copy(newSketch);
		return newSketch;
		}
		$p.addMethod($this_1, 'copy', copy$0);
		function countSelectedNodes$0() {
		return $this_1.sketchShapes.countSelectedNodes();
		}
		$p.addMethod($this_1, 'countSelectedNodes', countSelectedNodes$0);
		function deleteAll$0() {
		$this_1.$self.getSketchShapes().deleteAll();
		}
		$p.addMethod($this_1, 'deleteAll', deleteAll$0);
		function deleteSelectedNodes$0() {
		for (var i =  0;  i < $this_1.$self.getSelectedNodes().size();  i++) {
		var sketchP =   $this_1.$self.getSelectedNodes().get(i);
		$this_1.$self.removeVertex(sketchP);
		}
		$this_1.$self.buildOutline();
		}
		$p.addMethod($this_1, 'deleteSelectedNodes', deleteSelectedNodes$0);
		function deleteSelectedShapes$0() {
		$this_1.sketchShapes.deleteSelectedShapes();
		$this_1.$self.buildOutline();
		$this_1.$self.deleteSelectedNodes();
		}
		$p.addMethod($this_1, 'deleteSelectedShapes', deleteSelectedShapes$0);
		function flipHorizontal$1(centre) {
		$this_1.sketchShapes.flipHorizontal(centre);
		}
		$p.addMethod($this_1, 'flipHorizontal', flipHorizontal$1);
		function getApplet$0() {
		return null;
		}
		$p.addMethod($this_1, 'getApplet', getApplet$0);
		function getArea$0() {
		return $this_1.sketchShapes.getArea();
		}
		$p.addMethod($this_1, 'getArea', getArea$0);
		function getCentreOfMass$0() {
		return $this_1.sketchShapes.getCentreOfMass();
		}
		$p.addMethod($this_1, 'getCentreOfMass', getCentreOfMass$0);
		function getClosestPathVertex$1(pointOnPlan) {
		return $this_1.sketchShapes.getClosestPathVertex(pointOnPlan);
		}
		$p.addMethod($this_1, 'getClosestPathVertex', getClosestPathVertex$1);
		function getCurrentShape$0() {
		return $this_1.$self.getSketchShapes().currentShape;
		}
		$p.addMethod($this_1, 'getCurrentShape', getCurrentShape$0);
		function getFirst$0() {
		return $this_1.sketchShapes.getFirst();
		}
		$p.addMethod($this_1, 'getFirst', getFirst$0);
		function getHeight$0() {
		return $this_1.sketchShapes.getHeight();
		}
		$p.addMethod($this_1, 'getHeight', getHeight$0);
		function getLast$0() {
		return $this_1.sketchShapes.getLast();
		}
		$p.addMethod($this_1, 'getLast', getLast$0);
		function getLastVec$0() {
		return $this_1.sketchShapes.getLastVec();
		}
		$p.addMethod($this_1, 'getLastVec', getLastVec$0);
		function getLayerSelected$0() {
		return $this_1.layerSelected;
		}
		$p.addMethod($this_1, 'getLayerSelected', getLayerSelected$0);
		function getMaxX$0() {
		return $this_1.sketchShapes.getMaxX();
		}
		$p.addMethod($this_1, 'getMaxX', getMaxX$0);
		function getMaxXWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchShapes.sketchOutlines
		.getMaxXWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMaxXWorldSpace', getMaxXWorldSpace$1);
		function getMaxY$0() {
		return $this_1.sketchShapes.getMaxY();
		}
		$p.addMethod($this_1, 'getMaxY', getMaxY$0);
		function getMaxYWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchShapes.sketchOutlines
		.getMaxYWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMaxYWorldSpace', getMaxYWorldSpace$1);
		function getMinX$0() {
		return $this_1.sketchShapes.sketchOutlines.getMinX();
		}
		$p.addMethod($this_1, 'getMinX', getMinX$0);
		function getMinXWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchShapes.sketchOutlines
		.getMinXWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMinXWorldSpace', getMinXWorldSpace$1);
		function getMinY$0() {
		return $this_1.sketchShapes.sketchOutlines.getMinY();
		}
		$p.addMethod($this_1, 'getMinY', getMinY$0);
		function getMinYWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchShapes.sketchOutlines
		.getMinYWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMinYWorldSpace', getMinYWorldSpace$1);
		function getOnSketchPlane$0() {
		return $this_1.$self.getOnSlicePlane();
		}
		$p.addMethod($this_1, 'getOnSketchPlane', getOnSketchPlane$0);
		function getOnSlicePlane$0() {
		return $this_1.onSlicePlane;
		}
		$p.addMethod($this_1, 'getOnSlicePlane', getOnSlicePlane$0);
		function getOverSelectPoint$2(x, y) {
		return $this_1.sketchShapes.getOverSelectPoint(x, y);
		}
		$p.addMethod($this_1, 'getOverSelectPoint', getOverSelectPoint$2);
		function getOverShape$2(x, y) {
		return $this_1.sketchShapes.getOverShape(x, y);
		}
		$p.addMethod($this_1, 'getOverShape', getOverShape$2);
		function getRenderMode$0() {
		return $this_1.renderMode;
		}
		$p.addMethod($this_1, 'getRenderMode', getRenderMode$0);
		function getSelectedNodes$0() {
		return $this_1.selectedNodes;
		}
		$p.addMethod($this_1, 'getSelectedNodes', getSelectedNodes$0);
		function getSelectedShape$0() {
		return $this_1.$self.getSketchShapes().selectedShape;
		}
		$p.addMethod($this_1, 'getSelectedShape', getSelectedShape$0);
		function getShapePickBuffer$1(col) {
		return $this_1.sketchShapes.getShapePickBuffer(col);
		}
		$p.addMethod($this_1, 'getShapePickBuffer', getShapePickBuffer$1);
		function getSketchGlobals$0() {
		return $this_1.sketchGlobals;
		}
		$p.addMethod($this_1, 'getSketchGlobals', getSketchGlobals$0);
		function getSketchShapeById$1(linkedSketchId) {
		return $this_1.sketchShapes.getSketchShapeById(linkedSketchId);
		}
		$p.addMethod($this_1, 'getSketchShapeById', getSketchShapeById$1);
		function getSketchShapes$0() {
		return $this_1.sketchShapes;
		}
		$p.addMethod($this_1, 'getSketchShapes', getSketchShapes$0);
		function getSketchTools$0() {
		return $this_1.sketchTools;
		}
		$p.addMethod($this_1, 'getSketchTools', getSketchTools$0);
		function getSlots$0() {
		return $this_1.sketchShapes.getSlots();
		}
		$p.addMethod($this_1, 'getSlots', getSlots$0);
		function getspShape$0() {
		return $this_1.sketchShapes.getspShape();
		}
		$p.addMethod($this_1, 'getspShape', getspShape$0);
		function getVec2DpickBuffer$1(col) {
		return $this_1.sketchShapes.getVec2DpickBuffer(col);
		}
		$p.addMethod($this_1, 'getVec2DpickBuffer', getVec2DpickBuffer$1);
		function getZOOM$0() {
		return 1;
		}
		$p.addMethod($this_1, 'getZOOM', getZOOM$0);
		function isEditing$0() {
		return $this_1.sketchShapes.isEditing();
		}
		$p.addMethod($this_1, 'isEditing', isEditing$0);
		function isSelected$0() {
		return $this_1.sketchShapes.selected;
		}
		$p.addMethod($this_1, 'isSelected', isSelected$0);
		function lastSketchOverlaps$0() {
		return $this_1.sketchShapes.lastSketchOverlaps();
		}
		$p.addMethod($this_1, 'lastSketchOverlaps', lastSketchOverlaps$0);
		function mouseDragged$2(mouseX, mouseY) {
		$this_1.sketchShapes.mouseDragged(mouseX, mouseY);

		if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.DRAW_TOOL) {
		if ($this_1.$self.getCurrentShape() != null) {
		$this_1.$self.getCurrentShape().add(new SketchPoint(mouseX, mouseY));
		}
		}

		if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.LEG_TOOL) {
		var pointOnPlan =  new Vec2D(mouseX, mouseY);
		if ($this_1.$self.getLastVec() != null) {
		$this_1.$self.getLastVec().set(pointOnPlan.x, pointOnPlan.y);
		$this_1.$self.getCurrentShape().offset();
		}
		}
		}
		$p.addMethod($this_1, 'mouseDragged', mouseDragged$2);
		function mousePressed$2(mouseX, mouseY) {
		if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.DRAW_TOOL
		&& $this_1.$self.getSketchTools().getMouseButton() == SketchTools.MOUSE_LEFT) {
		var pointOnPlan =  new Vec2D(mouseX, mouseY);
		 var sp =  new SketchPoint(mouseX, mouseY);

		var newSketch =  new SketchSpline($this_1.$self,
		SketchSpline.OFFSET_BOTH);
		newSketch.setOffsetSize($this_1.$self.getSketchTools().brush_dia);
		newSketch.setCap($this_1.$self.getSketchTools().getCurrentCapType());
		newSketch.add(new SketchPoint(mouseX, mouseY));
		newSketch.setType(SketchShape.TYPE_SPLINE);
		$this_1.$self.add(newSketch);
		$this_1.$self.setCurrentShape(newSketch);
		}

		 if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.LEG_TOOL
		&& $this_1.$self.getSketchTools().getMouseButton() == SketchTools.MOUSE_LEFT) {
		var pointOnPlan =  new Vec2D(mouseX, mouseY);

		var newSketch =  new SketchSpline($this_1.$self,
		SketchSpline.OFFSET_BOTH);
		newSketch.setType(SketchSpline.TYPE_LEG);
		newSketch.setOffsetSize($this_1.$self.getSketchTools().brush_dia
		* SETTINGS_SKETCH.LEG_BRUSH_RATIO_TOP);
		 newSketch.getCentreOffset().put(
		1,
		$this_1.$self.getSketchTools().brush_dia
		* SETTINGS_SKETCH.LEG_BRUSH_RATIO_BOTTOM);
		newSketch.capType = SketchSpline.CAP_LEG;

		newSketch.add(new SketchPoint(pointOnPlan.x, pointOnPlan.y));
		newSketch.add(new SketchPoint(pointOnPlan.x, pointOnPlan.y));
		newSketch.path.editable = true;
		$this_1.$self.add(newSketch);
		$this_1.$self.setCurrentShape(newSketch);
		}

		if (($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.SELECT_TOOL || $this_1.$self.getSketchTools()
		.getCurrentTool() == SketchTools.SELECT_BEZIER_TOOL)
		&& $this_1.$self.getSketchTools().getMouseButton() == SketchTools.MOUSE_LEFT) {
		$this_1.$self.selectNodes(mouseX, mouseY);
		}

		if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.SELECT_BEZIER_TOOL
		&& $this_1.$self.getSelectedShape() != null && $this_1.$self.getSelectedNodes().size() > 0
		&& $this_1.$self.getSelectedNodes().get(0) != null) {
		if ($this_1.$self.getSelectedNodes().size() > 0) {
		var obj =   $this_1.$self.getSelectedNodes().get(0);
		if ($p.__instanceof(obj , SketchPoint)) {
		var selectedVec =   obj;
		if (!selectedVec.containsBezier()) {
		$this_1.$self.getSelectedShape().getPath().addBezier(
		 selectedVec, new Vec2D(selectedVec.x - 10,
		selectedVec.y + 10), new Vec2D(
		selectedVec.x + 10, selectedVec.y + 10));
		}
		}
		}
		}

		$this_1.$self.unSelectAll();
		}
		$p.addMethod($this_1, 'mousePressed', mousePressed$2);
		function mouseReleased$2(mouseX, mouseY) {
		$this_1.sketchShapes.mouseReleased(mouseX, mouseY);

		if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.DRAW_OFFSETPATH_TOOL) {
		var skip =  false;
		var pointOnPlan =  new Vec2D(mouseX, mouseY);

		if ($this_1.$self.getCurrentShape() != null
		&& $this_1.$self.getCurrentShape().getType() == SketchShape.OFFSET_SPLINE
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.RIGHT
		&& !$this_1.$self.getCurrentShape().getClosed() && !skip) {
		var spline =   $this_1.$self.getCurrentShape();
		spline.getCentrePath().remove(spline.getCentrePath().getLast());
		$this_1.$self.getCurrentShape().setClosed(true);
		spline.offset();
		skip = true;
		}

		if ($this_1.$self.getCurrentShape() != null
		&& ($this_1.$self.getCurrentShape().getType() != SketchShape.OFFSET_SPLINE || $this_1.$self.getCurrentShape()
		.getClosed())
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& !skip) {
		var sketch =  new SketchSpline($this_1.$self);
		sketch.setType(SketchShape.OFFSET_SPLINE);
		sketch.autoSmooth = false;
		sketch.setOffsetSize($this_1.$self.getSketchTools().brush_dia);
		sketch.setJoinType(SketchSpline.JOIN_ROUND);
		sketch.setCap($this_1.$self.getSketchTools().getCurrentCapType());
		$this_1.$self.add(sketch);
		}

		if ($this_1.$self.getCurrentShape() == null
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& !skip) {
		var sketch =  new SketchSpline($this_1.$self);
		sketch.setType(SketchShape.OFFSET_SPLINE);
		sketch.autoSmooth = false;
		sketch.setJoinType(SketchSpline.JOIN_ROUND);
		sketch.setOffsetSize($this_1.$self.getSketchTools().brush_dia);
		sketch.setCap($this_1.$self.getSketchTools().getCurrentCapType());
		$this_1.$self.add(sketch);
		}

		 if ($this_1.$self.getCurrentShape() != null
		&& $this_1.$self.getCurrentShape().getType() == SketchShape.OFFSET_SPLINE
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& !skip) {
		$this_1.$self.getCurrentShape().add(
		new SketchPoint(pointOnPlan.x, pointOnPlan.y));
		$this_1.$self.getCurrentShape().add(
		new SketchPoint(pointOnPlan.x + 10, pointOnPlan.y + 1));
		}
		}

		  if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.DRAW_PATH_TOOL) {
		var skip =  false;

		if (!skip && $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& $this_1.$self.getSketchTools().__keyPressed
		&& $this_1.$self.getSketchTools().keyCode == $p.PConstants.CONTROL) {
		var pointOnPlane =  new Vec2D(mouseX, mouseY);

		var pathVert =  $this_1.$self.getClosestPathVertex(pointOnPlane);

		if (pathVert != null && pointOnPlane.distanceTo(pathVert) < SETTINGS_SKETCH.select_dia) {
		$this_1.$self.removeVertex(pathVert);
		skip = true;
		}
		}

		 if (!skip && $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& $this_1.$self.getSketchTools().__keyPressed
		&& $this_1.$self.getSketchTools().keyCode == $p.PConstants.CONTROL) {
		var pointOnPlane =  new Vec2D(mouseX, mouseY);

		if ($this_1.$self.addPointAlongPath(pointOnPlane.x, pointOnPlane.y))
		skip = true;
		}

		if (!skip) {
		var pointOnPlan =  new Vec2D(mouseX, mouseY);
		if ($this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.RIGHT) {
		var pathVert =  $this_1.$self.getClosestPathVertex(pointOnPlan);

		if (pathVert != null
		&& pointOnPlan.distanceTo(pathVert) < SETTINGS_SKETCH.select_dia) {
		$this_1.$self.removeVertex(pathVert);
		skip = true;
		}
		}

		if ($this_1.$self.getCurrentShape() != null
		&& $this_1.$self.getCurrentShape().getType() == SketchShape.TYPE_PATH
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& !skip) {
		var sketchP =   $this_1.$self.getCurrentShape();
		if (sketchP.getClosed()) {
		var sketch =  new SketchPath($this_1.$self);
		sketch.setType(SketchShape.TYPE_PATH);
		$this_1.$self.add(sketch);
		$this_1.$self.getCurrentShape().add(
		new SketchPoint(pointOnPlan.x, pointOnPlan.y));
		}
		}

		if ($this_1.$self.getCurrentShape() == null
		|| $this_1.$self.getCurrentShape().getType() != SketchShape.TYPE_PATH
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& !skip) {
		var sketch =  new SketchPath($this_1.$self);
		sketch.setType(SketchShape.TYPE_PATH);
		sketch.setClosed(false);
		$this_1.$self.add(sketch);
		$this_1.$self.getCurrentShape().add(
		new SketchPoint(pointOnPlan.x, pointOnPlan.y));
		}

		if ($this_1.$self.getCurrentShape().getType() == SketchShape.TYPE_PATH
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& !skip) {
		if ($this_1.$self.getCurrentShape().selected
		&& $this_1.$self.getCurrentShape().getLength() > 0) {
		var firstPoint =   ( $this_1.$self.getCurrentShape())
		.get(0);
		var mousePos =  new Vec2D(mouseX, mouseY);

		 if (firstPoint.distanceTo(mousePos) < SETTINGS_SKETCH.MIN_CLOSE_SHAPE_DIST) {
		var path =   $this_1.$self.getCurrentShape();
		path.remove(path.getLast());
		( $this_1.$self.getCurrentShape()).setClosed(true);

		skip = true;
		}
		}
		}

		 if (($this_1.$self.getCurrentShape().getType() == SketchShape.TYPE_PATH || $this_1.$self.getCurrentShape()
		.getType() == SketchShape.TYPE_SPLINE)
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.LEFT
		&& !skip) {
		$this_1.$self.getCurrentShape().add(
		new SketchPoint(pointOnPlan.x, pointOnPlan.y));
		}

		if ($this_1.$self.getCurrentShape().getType() == SketchShape.TYPE_PATH
		&& $this_1.$self.getSketchTools().getMouseButton() == $p.PConstants.RIGHT
		&& !$this_1.$self.getCurrentShape().getClosed() && !skip) {
		var path =   $this_1.$self.getCurrentShape();
		path.remove(path.getLast());
		path.setClosed(true);
		}
		}
		}
		}
		$p.addMethod($this_1, 'mouseReleased', mouseReleased$2);
		function mouseDoubleClick$2(x, y) {
		$this_1.$self.selectShape(x, y)	;
		}
		$p.addMethod($this_1, 'mouseDoubleClick', mouseDoubleClick$2);
		function numerOfShapes$0() {
		return $this_1.$self.getSketchShapes().l.size();
		}
		$p.addMethod($this_1, 'numerOfShapes', numerOfShapes$0);
		function optimize$0() {
		$this_1.sketchShapes.optimize();
		}
		$p.addMethod($this_1, 'optimize', optimize$0);
		function overSelectPoint$2(mouseX, mouseY) {
		return $this_1.sketchShapes.overSelectPoint(mouseX, mouseY);
		}
		$p.addMethod($this_1, 'overSelectPoint', overSelectPoint$2);
		function removeLast$0() {
		$this_1.sketchShapes.removeLast();
		}
		$p.addMethod($this_1, 'removeLast', removeLast$0);
		function removeVertex$1(v) {
		$this_1.sketchShapes.removeVertex(v);
		}
		$p.addMethod($this_1, 'removeVertex', removeVertex$1);
		function render$1(g) {
			
			
		switch($this_1.$self.getRenderMode()){
		case Sketch.RENDER_3D_PREVIW:
		$this_1.sketchShapes.sketchOutlines.render(g);
		$this_1.sketchShapes.render(g);

		break;case Sketch.RENDER_3D_EDITING_PLANES:
		if ($this_1.$self.getLayerSelected() == true){
		if(!$this_1.sketchGlobals.__mousePressed)
		$this_1.sketchShapes.sketchOutlines.render(g);

		$this_1.$self.getSlots().render(g);
		$this_1.sketchShapes.render(g);
		}else{
		$this_1.sketchShapes.sketchOutlines.render(g);
		$this_1.sketchShapes.render(g);
		}
		break;case Sketch.RENDER_3D_DIAGRAM:
		$this_1.sketchShapes.sketchOutlines.render(g);
		$this_1.sketchShapes.render(g);

		var extrudeDepth =  $this_1.$self.getOnSketchPlane().thickness / 2;
		extrudeDepth /= SETTINGS_SKETCH.scale;

		g.stroke(SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED);
		g.strokeWeight(SETTINGS_SKETCH.sChair_selected_line_width*3);

		g.pushMatrix();
		g.translate(0, 0, extrudeDepth+SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET );
		$this_1.$self.getSlots().renderEdge(g);
		g.popMatrix();

		g.pushMatrix();
		g.translate(0, 0, -(extrudeDepth+SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET ));
		$this_1.$self.getSlots().renderEdge(g);
		g.popMatrix();

		$this_1.$self.getSlots().renderEdge(g);

		break;case Sketch.RENDER_3D_NORMAL:
		$this_1.sketchShapes.sketchOutlines.render(g);
		$this_1.sketchShapes.render(g);

		break;
		}
		}
		$p.addMethod($this_1, 'render', render$1);
		function renderOutline$1(g) {
		$this_1.sketchShapes.renderOutline(g);
		}
		$p.addMethod($this_1, 'renderOutline', renderOutline$1);
		function renderPickBuffer$1(g) {
		$this_1.sketchShapes.renderPickBuffer(g);
		}
		$p.addMethod($this_1, 'renderPickBuffer', renderPickBuffer$1);
		function renderSide$1(g) {
		$this_1.sketchShapes.renderSide(g);
		}
		$p.addMethod($this_1, 'renderSide', renderSide$1);
		function renderSilhouette$1(g) {
		$this_1.sketchShapes.renderSilhouette(g);
		}
		$p.addMethod($this_1, 'renderSilhouette', renderSilhouette$1);
		function scale$2(scale, centre) {
		$this_1.sketchShapes.scale(scale, centre);
		}
		$p.addMethod($this_1, 'scale', scale$2);
		function select$0() {
		$this_1.selected = true;
		}
		$p.addMethod($this_1, 'select', select$0);
		function selectNodes$2(x, y) {
		$this_1.sketchShapes.selectNodes(x, y);
		}
		$p.addMethod($this_1, 'selectNodes', selectNodes$2);
		function selectShape$2(x, y) {
		$this_1.sketchShapes.selectShape(x, y);
		}
		$p.addMethod($this_1, 'selectShape', selectShape$2);
		function setBrushCap$1(cap) {
		var sketch =  $this_1.$self.getSketchShapes().selectedShape;

		if ($p.__instanceof(sketch , SketchSpline)) {
		var spline =   sketch;
		spline.setCap(cap);
		spline.offset();
		}
		}
		$p.addMethod($this_1, 'setBrushCap', setBrushCap$1);
		function setBrushDia$1(val) {
		var sketch =  $this_1.$self.getSketchShapes().selectedShape;

		if ($p.__instanceof(sketch , SketchSpline)) {
		var spline =   sketch;
		spline.setOffsetSize(val);
		}

		for (var i =  0;  i < $this_1.$self.getSketchShapes().l.size();  i++) {
		var s =  $this_1.$self.getSketchShapes().l.get(i);
		if ($p.__instanceof(s , SketchSpline)) {
		var spline =   s;
		spline.setOffsetSizeCentre(val);
		spline.offset();
		}
		}
		}
		$p.addMethod($this_1, 'setBrushDia', setBrushDia$1);
		function setCurrentShape$1(newSketch) {
		$this_1.$self.getSketchShapes().currentShape = newSketch;
		}
		$p.addMethod($this_1, 'setCurrentShape', setCurrentShape$1);
		function setEditing$1(e) {
		$this_1.sketchShapes.editing = e;
		}
		$p.addMethod($this_1, 'setEditing', setEditing$1);
		function setLayerSelected$1(selected) {
		$this_1.layerSelected = selected;
		}
		$p.addMethod($this_1, 'setLayerSelected', setLayerSelected$1);
		function setOnSketchPlane$1(slicePlane) {
		$this_1.$self.setOnSlicePlane(slicePlane);
		}
		$p.addMethod($this_1, 'setOnSketchPlane', setOnSketchPlane$1);
		function setOnSlicePlane$1(sp) {
		$this_1.onSlicePlane = sp;
		}
		$p.addMethod($this_1, 'setOnSlicePlane', setOnSlicePlane$1);
		function setRenderMode$1(mode) {
		$this_1.renderMode = mode;
		}
		$p.addMethod($this_1, 'setRenderMode', setRenderMode$1);
		function setSketchGlobals$1(sGlobals) {
		$this_1.sketchGlobals = sGlobals;
		}
		$p.addMethod($this_1, 'setSketchGlobals', setSketchGlobals$1);
		function setSketchTools$1(sTools) {
		$this_1.sketchTools = sTools;
		}
		$p.addMethod($this_1, 'setSketchTools', setSketchTools$1);
		function setSlots$1(slots) {
		$this_1.sketchShapes.setSlots(slots);
		}
		$p.addMethod($this_1, 'setSlots', setSlots$1);
		function setVec2DpickBuffer$5(col, selectedVec, selectedShape, selectedVecPlane, isSelectedVecOnOutline) {
		return $this_1.sketchShapes.setVec2DpickBuffer(col, selectedVec, selectedShape,
		selectedVecPlane, isSelectedVecOnOutline);
		}
		$p.addMethod($this_1, 'setVec2DpickBuffer', setVec2DpickBuffer$5);
		function toggleUnion$0() {
		var sketch =  $this_1.$self.getSketchShapes().selectedShape;

		if (sketch.union == SketchShape.UNION_ADD)
		sketch.union = SketchShape.UNION_SUBTRACT;
		else
		sketch.union = SketchShape.UNION_ADD;
		}
		$p.addMethod($this_1, 'toggleUnion', toggleUnion$0);
		function toXML$0() {
		return $this_1.sketchShapes.toXML();
		}
		$p.addMethod($this_1, 'toXML', toXML$0);
		function unselect$0() {
		$this_1.selected = false;
		}
		$p.addMethod($this_1, 'unselect', unselect$0);
		function unSelectAll$0() {
		$this_1.sketchShapes.unSelectAll();
		}
		$p.addMethod($this_1, 'unSelectAll', unSelectAll$0);
		function update$0() {
		var pointOnPlan =  new Vec2D($this_1.$self.getSketchTools().mouseX,
		$this_1.$self.getSketchTools().mouseY);

		if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.DRAW_OFFSETPATH_TOOL) {
		var skip =  false;

		if ($this_1.$self.getCurrentShape() != null
		&& $this_1.$self.getCurrentShape().getType() == SketchShape.OFFSET_SPLINE
		&& !$this_1.$self.getCurrentShape().getClosed() && !skip) {
		var spline =   $this_1.$self.getCurrentShape();
		spline.getCentrePath().getLast().set(pointOnPlan);
		spline.offset();
		}
		}

		if ($this_1.$self.getSketchTools().getCurrentTool() == SketchTools.DRAW_PATH_TOOL) {
		if ($this_1.$self.getCurrentShape() != null
		&& $this_1.$self.getCurrentShape().getType() == SketchShape.TYPE_PATH
		&& !$this_1.$self.getCurrentShape().getClosed()) {
		var path =   $this_1.$self.getCurrentShape();
		path.getLast().set(pointOnPlan);
		}
		}

		  if ($this_1.$self.getSketchTools().getCurrentTool() != SketchTools.DRAW_OFFSETPATH_TOOL
		&& $this_1.$self.getCurrentShape() != null
		&& $this_1.$self.getCurrentShape().getType() == SketchShape.OFFSET_SPLINE
		&& !$this_1.$self.getCurrentShape().getClosed()) {
		var spline =   $this_1.$self.getCurrentShape();
		spline.getCentrePath().remove(spline.getCentrePath().getLast());
		$this_1.$self.getCurrentShape().setClosed(true);
		spline.offset();
		}

		if ($this_1.$self.getSketchTools().getCurrentTool() != SketchTools.DRAW_PATH_TOOL
		&& $this_1.$self.getCurrentShape() != null
		&& $this_1.$self.getCurrentShape().getType() == SketchShape.TYPE_PATH
		&& !$this_1.$self.getCurrentShape().getClosed()) {
		var path =   $this_1.$self.getCurrentShape();
		path.remove(path.getLast());
		$this_1.$self.getCurrentShape().setClosed(true);
		}
		}
		$p.addMethod($this_1, 'update', update$0);
		function removeLegs$0() {
		$this_1.sketchShapes.removeLegs();
		}
		$p.addMethod($this_1, 'removeLegs', removeLegs$0);
		function importSVG$1(path) {
		var fileUri =  null;
		try {
		fileUri = new URI("file://"+path);
		} catch (e) {
		$p.__printStackTrace(e);
		}
		var diagram =  SVGCache.getSVGUniverse().getDiagram(fileUri);

		  var element =  diagram.getElement("shape_01");
		var vector =  element.getPath(null);
		var pathSVG =   vector.get(1);  
		var shape =  pathSVG.getShape();
		$this_1.sketchShapes.buildPathsFromAWTShape(shape);
		}
		$p.addMethod($this_1, 'importSVG', importSVG$1);
		function setEditable$1(editable) {
		$this_1.sketchShapes.setEditable(editable);
		}
		$p.addMethod($this_1, 'setEditable', setEditable$1);
		function setRender3D$1(b) {
		$this_1.render3D = b;
		}
		$p.addMethod($this_1, 'setRender3D', setRender3D$1);
		function getRender3D$0() {
		return $this_1.render3D;
		}
		$p.addMethod($this_1, 'getRender3D', getRender3D$0);
		function unselectShapes$0() {
		$this_1.sketchShapes.unSelectAll();
		}
		$p.addMethod($this_1, 'unselectShapes', unselectShapes$0);
		function $constr_1(app){
		$superCstr();

		$this_1.sketchShapes = new SketchShapes($this_1.$self);
		$this_1.$self.setSketchTools(new SketchTools(app));
		$this_1.$self.setSketchGlobals(new SketchGlobals());
		}

		function $constr_2(sTools, sGlobals){
		$superCstr();

		$this_1.sketchShapes = new SketchShapes($this_1.$self);
		$this_1.$self.setSketchTools(sTools);
		$this_1.$self.setSketchGlobals(sGlobals);
		}

		function $constr_3(sTools, sGlobals, element){
		$superCstr();

		$this_1.$self.setSketchTools(sTools);
		$this_1.$self.setSketchGlobals(sGlobals);
		$this_1.sketchShapes = new SketchShapes($this_1.$self, element);
		}

		function $constr_3(sTools, sGlobals, slice){
		$superCstr();

		$this_1.sketchShapes = new SketchShapes($this_1.$self);
		$this_1.sketchShapes.onSlicePlane = slice;
		$this_1.$self.setSketchTools(sTools);
		$this_1.$self.setSketchGlobals(sGlobals);
		}

		function $constr() {
		if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else if(arguments.length === 3) { $constr_3.apply($this_1, arguments); } else if(arguments.length === 3) { $constr_3.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		Sketch.RENDER_3D_EDITING_PLANES =  1;
		Sketch.RENDER_3D_PREVIW =  2;
		Sketch.RENDER_3D_DIAGRAM =  3;
		Sketch.RENDER_EDIT_SELECT =  4;
		Sketch.RENDER_3D_NORMAL =  5;
		return Sketch;
		})();
		$p.Sketch = Sketch;
		var functions = (function() {
		function functions() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$p.defineProperty($this_1, 'DONT_INTERSECT', {get: function(){return functions.DONT_INTERSECT}, set: function(val){functions.DONT_INTERSECT = val}});
		$p.defineProperty($this_1, 'COLLINEAR', {get: function(){return functions.COLLINEAR}, set: function(val){functions.COLLINEAR = val}});
		$p.defineProperty($this_1, 'DO_INTERSECT', {get: function(){return functions.DO_INTERSECT}, set: function(val){functions.DO_INTERSECT = val}});
		$p.defineProperty($this_1, 'x', {get: function(){return functions.x}, set: function(val){functions.x = val}});
		$p.defineProperty($this_1, 'y', {get: function(){return functions.y}, set: function(val){functions.y = val}});
		$p.addMethod($this_1, 'angleOf', angleOf$1);
		$p.addMethod($this_1, 'angleOfDot', angleOfDot$1);
		$p.addMethod($this_1, 'bezierPoint', bezierPoint$5);
		$p.addMethod($this_1, 'color', color$3);
		$p.addMethod($this_1, 'curvePoint', curvePoint$5);
		$p.addMethod($this_1, 'cylinder', cylinder$5);
		$p.addMethod($this_1, 'cylinder', cylinder$4_2);
		$p.addMethod($this_1, 'fileExists', fileExists$1);
		$p.addMethod($this_1, 'getComputerName', getComputerName$0);
		$p.addMethod($this_1, 'getFileName', getFileName$0);
		$p.addMethod($this_1, 'getIndexBuffer', getIndexBuffer$1);
		$p.addMethod($this_1, 'getVertexBuffer', getVertexBuffer$1);
		$p.addMethod($this_1, 'intersect', intersect$8);
		$p.addMethod($this_1, 'intersect', intersect$6_2);
		$p.addMethod($this_1, 'intersect', intersect$8_3);
		$p.addMethod($this_1, 'same_sign', same_sign$2);
		function color$3_2(x, y, z) {
		if (x > 255)
		x = 255;
		else if (x < 0)
		x = 0;
		if (y > 255)
		y = 255;
		else if (y < 0)
		y = 0;
		if (z > 255)
		z = 255;
		else if (z < 0)
		z = 0;

		return 0xff000000 | ( $p.__int_cast(x) << 16) | ( $p.__int_cast(y) << 8) |  $p.__int_cast(z);
		}
		$p.addMethod($this_1, 'color', color$3_2);
		function color$4_3(x, y, z, a) {
		if (a > 255)
		a = 255;
		else if (a < 0)
		a = 0;
		if (x > 255)
		x = 255;
		else if (x < 0)
		x = 0;
		if (y > 255)
		y = 255;
		else if (y < 0)
		y = 0;
		if (z > 255)
		z = 255;
		else if (z < 0)
		z = 0;

		return ( $p.__int_cast(a) << 24) | ( $p.__int_cast(x) << 16) | ( $p.__int_cast(y) << 8) |  $p.__int_cast(z);
		}
		$p.addMethod($this_1, 'color', color$4_3);
		$p.addMethod($this_1, 'color', color$4_4);
		$p.addMethod($this_1, 'rotate', rotate$3);
		$p.addMethod($this_1, 'getRange', getRange$3);
		function $constr() {
		$superCstr();
		}
		$constr.apply(null, arguments);
		}
		functions.DONT_INTERSECT =  0;
		functions.COLLINEAR =  1;
		functions.DO_INTERSECT =  2;
		functions.x =  0;
		functions.y =  0;
		function angleOf$1(v1) {
		v1.normalize();
		var an =   Math.atan2(v1.y, v1.x);

		if (an > 0.0) {
		an =  (Math.PI + (Math.PI - an));
		} else {
		an =  (Math.PI - (Math.PI - Math.abs(an)));
		}

		return an;
		}
		$p.addMethod(functions, 'angleOf', angleOf$1);
		function angleOfDot$1(v1) {
		v1.normalize();

		var an =   Math.acos(v1.dot(new Vec2D(0, 0)));

		return  Math.atan2(v1.y, v1.x);
		}
		$p.addMethod(functions, 'angleOfDot', angleOfDot$1);
		function bezierPoint$5(a, b, c, d, t) {
		var t1 =  1.0 - t;
		return a * t1 * t1 * t1 + 3 * b * t * t1 * t1 + 3 * c * t * t * t1 + d
		* t * t * t;
		}
		$p.addMethod(functions, 'bezierPoint', bezierPoint$5);
		function color$3(x, y, z) {
		if (x > 255)
		x = 255;
		else if (x < 0)
		x = 0;
		if (y > 255)
		y = 255;
		else if (y < 0)
		y = 0;
		if (z > 255)
		z = 255;
		else if (z < 0)
		z = 0;

		return 0xff000000 | (x << 16) | (y << 8) | z;
		}
		$p.addMethod(functions, 'color', color$3);
		function curvePoint$5(x2, x3, x4, x5, t) {
		return 0;
		}
		$p.addMethod(functions, 'curvePoint', curvePoint$5);
		function cylinder$5(w1, w2, h, sides, g) {
		var angle = 0;
		var x1 =  $p.createJavaArray('float', [sides + 1]);
		var z1 =  $p.createJavaArray('float', [sides + 1]);

		var x2 =  $p.createJavaArray('float', [sides + 1]);
		var z2 =  $p.createJavaArray('float', [sides + 1]);

		 for (var i =  0;  i < x1.length;  i++) {
		angle =  ((Math.PI * 2) / (sides) * i + 1);
		x1[i] =  (Math.sin(angle) * w1);
		z1[i] =  (Math.cos(angle) * w1);
		}

		 for (var i =  0;  i < x2.length;  i++) {
		angle =  ((Math.PI * 2) / (sides) * i + 1);
		x2[i] =  (Math.sin(angle) * w2);
		z2[i] =  (Math.cos(angle) * w2);
		}

		 g.beginShape($p.PConstants.TRIANGLE_FAN);

		g.vertex(0, -h / 2, 0);

		for (var i =  0;  i < x1.length;  i++) {
		g.vertex(x1[i], -h / 2, z1[i]);
		}

		g.endShape();

		 g.beginShape($p.PConstants.QUAD_STRIP);

		for (var i =  0;  i < x1.length;  i++) {
		g.vertex(x1[i], -h / 2, z1[i]);
		g.vertex(x2[i], h / 2, z2[i]);
		}

		g.endShape();

		 g.beginShape($p.PConstants.TRIANGLE_FAN);

		g.vertex(0, h / 2, 0);

		for (var i =  0;  i < x2.length;  i++) {
		g.vertex(x2[i], h / 2, z2[i]);
		}

		g.endShape();
		}
		$p.addMethod(functions, 'cylinder', cylinder$5);
		function cylinder$4_2(w, h, sides, g) {
		var angle = 0;
		var x =  $p.createJavaArray('float', [sides + 1]);
		var z =  $p.createJavaArray('float', [sides + 1]);

		 for (var i =  0;  i < x.length;  i++) {
		angle =  ((Math.PI * 2) / (sides) * i);
		x[i] =  (Math.sin(angle) * w);
		z[i] =  (Math.cos(angle) * w);
		}

		 g.beginShape($p.PConstants.TRIANGLE_FAN);

		g.vertex(0, -h / 2, 0);

		for (var i =  0;  i < x.length;  i++) {
		g.vertex(x[i], -h / 2, z[i]);
		}

		g.endShape();

		 g.beginShape($p.PConstants.QUAD_STRIP);

		for (var i =  0;  i < x.length;  i++) {
		g.vertex(x[i], -h / 2, z[i]);
		g.vertex(x[i], h / 2, z[i]);
		}

		g.endShape();

		 g.beginShape($p.PConstants.TRIANGLE_FAN);

		g.vertex(0, h / 2, 0);

		for (var i =  0;  i < x.length;  i++) {
		g.vertex(x[i], h / 2, z[i]);
		}

		g.endShape();
		}
		$p.addMethod(functions, 'cylinder', cylinder$4_2);
		function fileExists$1(filename) {
		var file =  new File(filename);

		if (!file.exists())
		return false;

		return true;
		}
		$p.addMethod(functions, 'fileExists', fileExists$1);
		function getComputerName$0() {
		return "name";
		}
		$p.addMethod(functions, 'getComputerName', getComputerName$0);
		function getFileName$0() {
		var now =  Calendar.getInstance();
		var time =  now.getTimeInMillis();
		return time.toString();
		}
		$p.addMethod(functions, 'getFileName', getFileName$0);
		function getIndexBuffer$1(indices) {
		var buf =  ByteBuffer.allocateDirect(indices.length * 4).order(
		ByteOrder.nativeOrder());
		for (var i =  0;  i < indices.length;  i++) {
		buf.putInt(indices[i]);
		}
		buf.flip();
		return buf;
		}
		$p.addMethod(functions, 'getIndexBuffer', getIndexBuffer$1);
		function getVertexBuffer$1(vertices) {
		var buf =  ByteBuffer.allocateDirect(vertices.length * 4).order(
		ByteOrder.nativeOrder());
		for (var i =  0;  i < vertices.length;  i++) {
		buf.putFloat(vertices[i]);
		}
		buf.flip();
		return buf;
		}
		$p.addMethod(functions, 'getVertexBuffer', getVertexBuffer$1);
		function intersect$8(x1, y1, x2, y2, x3, y3, x4, y4) {
		var a1 = 0,a2 = 0,b1 = 0,b2 = 0,c1 = 0,c2 = 0;
		var r1 = 0,r2 = 0,r3 = 0,r4 = 0;
		var denom = 0,offset = 0,num = 0;

		  a1 = y2 - y1;
		b1 = x1 - x2;
		c1 = (x2 * y1) - (x1 * y2);

		 r3 = ((a1 * x3) + (b1 * y3) + c1);
		r4 = ((a1 * x4) + (b1 * y4) + c1);

		  if ((r3 != 0) && (r4 != 0) && functions.same_sign(r3, r4)) {
		return functions.DONT_INTERSECT;
		}

		 a2 = y4 - y3;
		b2 = x3 - x4;
		c2 = (x4 * y3) - (x3 * y4);

		 r1 = (a2 * x1) + (b2 * y1) + c2;
		r2 = (a2 * x2) + (b2 * y2) + c2;

		   if ((r1 != 0) && (r2 != 0) && (functions.same_sign(r1, r2))) {
		return functions.DONT_INTERSECT;
		}

		 denom = (a1 * b2) - (a2 * b1);

		if (denom == 0) {
		return functions.COLLINEAR;
		}

		if (denom < 0) {
		offset = -denom / 2;
		} else {
		offset = denom / 2;
		}

		   num = (b1 * c2) - (b2 * c1);
		if (num < 0) {
		functions.x = (num - offset) / denom;
		} else {
		functions.x = (num + offset) / denom;
		}

		num = (a2 * c1) - (a1 * c2);
		if (num < 0) {
		functions.y = (num - offset) / denom;
		} else {
		functions.y = (num + offset) / denom;
		}

		 return functions.DO_INTERSECT;
		}
		$p.addMethod(functions, 'intersect', intersect$8);
		function intersect$6_2(a1, a2, b1, b2, b3, b4) {
		if (functions.intersect(a1.x, a1.y, a2.x, a2.y, b1.x, b1.y, b2.x, b2.y) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		if (functions.intersect(a1.x, a1.y, a2.x, a2.y, b2.x, b2.y, b3.x, b3.y) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		if (functions.intersect(a1.x, a1.y, a2.x, a2.y, b3.x, b3.y, b4.x, b4.y) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		if (functions.intersect(a1.x, a1.y, a2.x, a2.y, b4.x, b4.y, b1.x, b1.y) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		return functions.DONT_INTERSECT;
		}
		$p.addMethod(functions, 'intersect', intersect$6_2);
		function intersect$8_3(a1, a2, a3, a4, b1, b2, b3, b4) {
		if (functions.intersect(a1, a2, b1, b2, b3, b4) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		if (functions.intersect(a2, a3, b1, b2, b3, b4) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		if (functions.intersect(a3, a4, b1, b2, b3, b4) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		if (functions.intersect(a4, a1, b1, b2, b3, b4) == functions.DO_INTERSECT)
		return functions.DO_INTERSECT;

		return functions.DONT_INTERSECT;
		}
		$p.addMethod(functions, 'intersect', intersect$8_3);
		function same_sign$2(a, b) {
		return ((a * b) >= 0);
		}
		$p.addMethod(functions, 'same_sign', same_sign$2);
		function color$4_4(x, y, z, a) {
		if (a > 255)
		a = 255;
		else if (a < 0)
		a = 0;
		if (x > 255)
		x = 255;
		else if (x < 0)
		x = 0;
		if (y > 255)
		y = 255;
		else if (y < 0)
		y = 0;
		if (z > 255)
		z = 255;
		else if (z < 0)
		z = 0;

		return (a << 24) | (x << 16) | (y << 8) | z;
		}
		$p.addMethod(functions, 'color', color$4_4);
		function rotate$3(curVec, center, r) {
		var returnVec =  curVec.copy();
		returnVec.subSelf(center);
		returnVec.rotate(r);
		returnVec.addSelf(center);
		return returnVec;
		}
		$p.addMethod(functions, 'rotate', rotate$3);
		function getRange$3(l, start, end) {
		var returnList =  new $p.ArrayList();
		for(var i =  start;  i <= end;  i++)
		returnList.add(l.get(i));

		return returnList;
		}
		$p.addMethod(functions, 'getRange', getRange$3);
		return functions;
		})();
		$p.functions = functions;
		var SketchShapes = (function() {
			
			
			
			
		function SketchShapes() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$this_1.l =  new $p.ArrayList();
		$this_1.currentShape =  null;
		$this_1.selectedShape =  null;
		$this_1.sketchOutlines =  new SketchOutlines($this_1.$self);
		$this_1.onSlicePlane =  null;
		$this_1.slots =  new SliceSlots();
		$this_1.renderShapes =  false;
		$this_1.selected =  true;
		$this_1.editing =  true;
		$this_1.preview = false;
		$this_1.parentSketch = null;
		function add$1(sketchShape) {
		$this_1.currentShape = sketchShape;
		$this_1.l.add(sketchShape);

		if ($p.__instanceof(sketchShape , SketchSpline
		)&& ( sketchShape).path != null)
		( sketchShape).path.parentSketch = $this_1.parentSketch;
		}
		$p.addMethod($this_1, 'add', add$1);
		function addAll$1(shapes) {
		$this_1.l.addAll(shapes);
		}
		$p.addMethod($this_1, 'addAll', addAll$1);
		function addPointAlongPath$2(x, y) {
		var closestPoint =  null;
		var closestShape =  null;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		if ($p.__instanceof(curSketch , SketchPath
		)|| $p.__instanceof(curSketch , SketchSpline)) {
		var pointOnPath =  curSketch.getClosestPointAlongPath(x, y);

		if ((pointOnPath != null && closestPoint == null)
		|| (pointOnPath != null && pointOnPath
		.distanceTo(new Vec2D(x, y)) < closestPoint
		.distanceTo(new Vec2D(x, y)))) {
		closestPoint = new SketchPoint(pointOnPath.copy());
		closestShape = curSketch;
		}
		}
		}

		if (closestPoint != null
		&& closestPoint.distanceTo(new Vec2D(x, y)) < SETTINGS_SKETCH.select_dia) {
		closestShape.insertPoint(closestPoint);
		return true;
		} else {
		return false;
		}
		}
		$p.addMethod($this_1, 'addPointAlongPath', addPointAlongPath$2);
		function buildOutline$0() {
		$this_1.$self.buildOutline(true, true);
		}
		$p.addMethod($this_1, 'buildOutline', buildOutline$0);
		function buildOutline$2_2(addSlots, includeSlots) {
		$this_1.sketchOutlines.clear();

		if ($this_1.l.size() < 1)
		return;

		var outlineArea =  new Area();

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		var gPath =  curSketch.getOutlineGeneralPath();

		if (curSketch.union == SketchShape.UNION_ADD)
		outlineArea.add(new Area(gPath));

		if (curSketch.union == SketchShape.UNION_SUBTRACT)
		outlineArea.subtract(new Area(gPath));
		}
		if (addSlots) {
		for (var k =  0;  k < $this_1.$self.getSlots().size();  k++) {
		var slot =  $this_1.$self.getSlots().get(k);

		if (slot.type == SliceSlot.FINGER
		|| slot.type == SliceSlot.SLOTS_AND_FINGER) {
		var area =  slot.getOutlineGeneralPathFingers();
		outlineArea.add(area);
		}
		}

		if (includeSlots) {
		for (var k =  0;  k < $this_1.$self.getSlots().size();  k++) {
		var slot =  $this_1.$self.getSlots().get(k);

		if (slot.type == SliceSlot.SLOT
		|| slot.type == SliceSlot.SLOTS_AND_FINGER) {
		var area =  slot.getOutlineGeneralPath();
		outlineArea.subtract(area);
		}
		}
		} else {
		for (var k =  0;  k < $this_1.$self.getSlots().size();  k++) {
		var slot =  $this_1.$self.getSlots().get(k);
		if (slot.type == SliceSlot.SLOT
		|| slot.type == SliceSlot.SLOTS_AND_FINGER) {
		slot.buildSketchOutlines($this_1.sketchOutlines,
		$this_1.parentSketch);
		}
		}
		}
		}

		$this_1.$self.buildOutlinesFromAWTShape(outlineArea);
		}
		$p.addMethod($this_1, 'buildOutline', buildOutline$2_2);
		function buildPathsFromAWTShape$1(awtShape) {
		var iter =  awtShape.getPathIterator(null);
		var path =  new SketchPath($this_1.$self.getParentSketch());
		var coords =  $p.createJavaArray('float', [6]);
		var bezier =  null;
		var prevVec =  null;

		while (!iter.isDone()) {
		switch (iter.currentSegment(coords)) {
		case PathIterator.SEG_MOVETO:  $this_1.$self.add(path);
		path = new SketchPath($this_1.$self.getParentSketch());
		path.add(new SketchPoint(coords[0], coords[1]));

		break;case PathIterator.SEG_LINETO:  path.add(new SketchPoint(coords[0], coords[1]));
		break;case PathIterator.SEG_QUADTO:  break;case PathIterator.SEG_CUBICTO:  
		prevVec = path.getPath().getLast();
		var newVec =  new SketchPoint(coords[4], coords[5]);
		var controlNodeBack =  new Vec2D(coords[0], coords[1]);
		var controlNodeFoward =  new Vec2D(coords[2], coords[3]);

		newVec.controlPoint1 = controlNodeFoward;

		if (prevVec != null) {
		prevVec.controlPoint2 = controlNodeBack;
		path.set(path.size() - 1,
		prevVec);
		}
		path.add(newVec);
		break;case PathIterator.SEG_CLOSE:
		break;
		}
		iter.next();
		}

		$this_1.$self.add(path);
		}
		$p.addMethod($this_1, 'buildPathsFromAWTShape', buildPathsFromAWTShape$1);
		function buildOutlinesFromAWTShape$1(awtShape) {
		var iter =  awtShape.getPathIterator(null);
		 var sktOutline =  new SketchOutline($this_1.$self.getParentSketch());

		var coords =  $p.createJavaArray('float', [6]);
		var bezier =  null;

		var prevVec =  null;
		while (!iter.isDone()) {
		switch (iter.currentSegment(coords)) {
		case PathIterator.SEG_MOVETO:  $this_1.sketchOutlines.add(sktOutline);
		sktOutline = new SketchOutline($this_1.$self.getParentSketch());
		sktOutline.getPath().add(new SketchPoint(coords[0], coords[1]));

		break;case PathIterator.SEG_LINETO:   sktOutline.getPath().add(new SketchPoint(coords[0], coords[1]));
		break;case PathIterator.SEG_QUADTO:   break;case PathIterator.SEG_CUBICTO:  
		prevVec = sktOutline.getPath().getLast();
		var newVec =  new SketchPoint(coords[4], coords[5]);

		var controlNodeBack =  new Vec2D(coords[0], coords[1]);
		var controlNodeFoward =  new Vec2D(coords[2], coords[3]);

		newVec.controlPoint1 = controlNodeFoward;

		if (prevVec != null) {
		prevVec.controlPoint2 = controlNodeBack;
		sktOutline.getPath().set(sktOutline.getPath().size() - 1,
		prevVec);
		}
		sktOutline.getPath().add(newVec);

		break;case PathIterator.SEG_CLOSE:

		break;
		}
		iter.next();
		}

		$this_1.sketchOutlines.add(sktOutline);
		}
		$p.addMethod($this_1, 'buildOutlinesFromAWTShape', buildOutlinesFromAWTShape$1);
		function clone$0() {
		var returnsketchShapes =  new SketchShapes($this_1.$self.getParentSketch(),
		$this_1.onSlicePlane);

		var curCloned =  null;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);

		var clonedShape =  curSketch.clone();

		if (curSketch == $this_1.currentShape)
		returnsketchShapes.currentShape = clonedShape;

		returnsketchShapes.add(clonedShape);
		}
		returnsketchShapes.buildOutline();
		return returnsketchShapes;
		}
		$p.addMethod($this_1, 'clone', clone$0);
		function contains$1(path) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);

		if ($p.__instanceof(curSketch , SketchSpline
		)&& ( curSketch).path == path)
		return true;

		if ($p.__instanceof(curSketch , SketchSpline
		)&& ( curSketch).getCentrePath() == path)
		return true;

		if (curSketch == path)
		return true;
		}

		return false;
		}
		$p.addMethod($this_1, 'contains', contains$1);
		function copy$1(parentSketch) {
		var newSketchShapes =  new SketchShapes(parentSketch);

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		newSketchShapes.add(curSketch.copy(parentSketch));
		}

		return newSketchShapes;
		}
		$p.addMethod($this_1, 'copy', copy$1);
		function countSelectedNodes$0() {
		var count =  0;

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		count += curSketch.countSelectedNodes();
		}
		return count;
		}
		$p.addMethod($this_1, 'countSelectedNodes', countSelectedNodes$0);
		function deleteAll$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.destroy();
		}

		$this_1.l.clear();
		}
		$p.addMethod($this_1, 'deleteAll', deleteAll$0);
		function deleteSelectedShapes$0() {
		if ($this_1.selectedShape != null)
		$this_1.selectedShape.destroy();

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		if (curSketch.selected) {
		curSketch.destroy();
		}
		}
		}
		$p.addMethod($this_1, 'deleteSelectedShapes', deleteSelectedShapes$0);
		function flipHorizontal$1(centre) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.flipHorizontal(centre);
		}
		$this_1.sketchOutlines.flipHorizontal(centre);
		}
		$p.addMethod($this_1, 'flipHorizontal', flipHorizontal$1);
		function getArea$0() {
		return $this_1.sketchOutlines.getArea();
		}
		$p.addMethod($this_1, 'getArea', getArea$0);
		function getCentreOfMass$0() {
		return $this_1.sketchOutlines.getCentreOfMass();
		}
		$p.addMethod($this_1, 'getCentreOfMass', getCentreOfMass$0);
		function getClosest$2(mouseX, mouseY) {
		var closestDist =  -1;
		var returnShape =  null;
		var mPos =  new Vec2D(mouseX, mouseY);

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);

		var closestPointTemp =  curSketch.getClosestPointAlongPath(mouseX,
		mouseY);

		if (returnShape == null
		|| closestPointTemp.distanceTo(mPos) < closestDist) {
		closestDist = closestPointTemp.distanceTo(mPos);
		returnShape = curSketch;
		}
		}
		return returnShape;
		}
		$p.addMethod($this_1, 'getClosest', getClosest$2);
		function getClosestPathVertex$1(pointOnPlan) {
		var closestpoint =  null;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);

		if ($p.__instanceof(curSketch , SketchPath)) {
		var p =  curSketch.getClosestPoint(pointOnPlan);

		if (closestpoint == null
		|| pointOnPlan.distanceTo(p) < pointOnPlan
		.distanceTo(closestpoint))
		closestpoint = p;
		}

		if ($p.__instanceof(curSketch , SketchSpline)) {
		var p =  ( curSketch).getCentrePath().getClosestPoint(pointOnPlan);
		if (closestpoint == null
		|| pointOnPlan.distanceTo(p) < pointOnPlan
		.distanceTo(closestpoint))
		closestpoint = p;
		}
		}
		return closestpoint;
		}
		$p.addMethod($this_1, 'getClosestPathVertex', getClosestPathVertex$1);
		function getFirst$0() {
		if ($this_1.l.size() > 0)
		return $this_1.l.get(0);
		else
		return null;
		}
		$p.addMethod($this_1, 'getFirst', getFirst$0);
		function getHeight$0() {
		return $this_1.sketchOutlines.getHeight();
		}
		$p.addMethod($this_1, 'getHeight', getHeight$0);
		function getLast$0() {
		if ($this_1.l.size() > 0)
		return $this_1.l.get($this_1.l.size() - 1);
		else
		return null;
		}
		$p.addMethod($this_1, 'getLast', getLast$0);
		function getLastVec$0() {
		return $this_1.$self.getLast().getLast();
		}
		$p.addMethod($this_1, 'getLastVec', getLastVec$0);
		function getMaxX$0() {
		return $this_1.sketchOutlines.getMaxX();
		}
		$p.addMethod($this_1, 'getMaxX', getMaxX$0);
		function getMaxXWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchOutlines.getMaxXWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMaxXWorldSpace', getMaxXWorldSpace$1);
		function getMaxY$0() {
		return $this_1.sketchOutlines.getMaxY();
		}
		$p.addMethod($this_1, 'getMaxY', getMaxY$0);
		function getMaxYWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchOutlines.getMaxYWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMaxYWorldSpace', getMaxYWorldSpace$1);
		function getMinX$0() {
		return $this_1.sketchOutlines.getMinX();
		}
		$p.addMethod($this_1, 'getMinX', getMinX$0);
		function getMinXWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchOutlines.getMinXWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMinXWorldSpace', getMinXWorldSpace$1);
		function getMinY$0() {
		return $this_1.sketchOutlines.getMinY();
		}
		$p.addMethod($this_1, 'getMinY', getMinY$0);
		function getMinYWorldSpace$1(currentWorldTransform) {
		return $this_1.sketchOutlines.getMinYWorldSpace(currentWorldTransform);
		}
		$p.addMethod($this_1, 'getMinYWorldSpace', getMinYWorldSpace$1);
		function getOverSelectPoint$2(x, y) {
		var pointOnPlan =  new Vec2D(x, y);
		var p =  $this_1.$self.getClosestPathVertex(pointOnPlan);

		if (p != null && pointOnPlan.distanceTo(p) < SETTINGS_SKETCH.select_dia)
		return p;
		else
		return null;
		}
		$p.addMethod($this_1, 'getOverSelectPoint', getOverSelectPoint$2);
		function getOverShape$2(x, y) {
		var overShapes =  new $p.ArrayList();

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		var returnedSketch =  curSketch.getOverShape(x, y);
		if (returnedSketch != null)
		overShapes.add(returnedSketch);
		}
		return overShapes;
		}
		$p.addMethod($this_1, 'getOverShape', getOverShape$2);
		function getParentSketch$0() {
		return $this_1.parentSketch;
		}
		$p.addMethod($this_1, 'getParentSketch', getParentSketch$0);
		function getShapePickBuffer$1(col) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		var ret =  curSketch.getVec2DpickBuffer(col);

		if (ret != null) {
		return curSketch;
		}
		}
		return null;
		}
		$p.addMethod($this_1, 'getShapePickBuffer', getShapePickBuffer$1);
		function getSketchShapeById$1(linkedSketchId) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);

		if ($p.__instanceof(curSketch , SketchSpline
		)&& ( curSketch).path.getId() == linkedSketchId)
		return ( curSketch).path;

		if ($p.__instanceof(curSketch , SketchSpline
		)&& ( curSketch).getCentrePath().getId() == linkedSketchId)
		return ( curSketch).getCentrePath();

		if (curSketch.getId() == linkedSketchId)
		return curSketch;
		}

		return null;
		}
		$p.addMethod($this_1, 'getSketchShapeById', getSketchShapeById$1);
		function getSlots$0() {
		return $this_1.slots;
		}
		$p.addMethod($this_1, 'getSlots', getSlots$0);
		function getspShape$0() {
		if ($this_1.$self.getParentSketch().getSketchGlobals().seperate_slots) {
		$this_1.$self.buildOutline(true, false);
		} else {
		$this_1.$self.buildOutline(true, true);
		}

		var returnShape =  $this_1.sketchOutlines.getspShape();

		 $this_1.$self.buildOutline(false, false);
		$this_1.sketchOutlines.addCollisionToSpShape(returnShape);

		return returnShape;
		}
		$p.addMethod($this_1, 'getspShape', getspShape$0);
		function getVec2DpickBuffer$1(col) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		var ret =  curSketch.getVec2DpickBuffer(col);
		if (ret != null)
		return ret;
		}
		return null;
		}
		$p.addMethod($this_1, 'getVec2DpickBuffer', getVec2DpickBuffer$1);
		function isEditing$0() {
		return true;
		}
		$p.addMethod($this_1, 'isEditing', isEditing$0);
		function isSelected$0() {
		return $this_1.selected;
		}
		$p.addMethod($this_1, 'isSelected', isSelected$0);
		function lastSketchOverlaps$0() {
		var overlaps =  false;
		if ($this_1.l.size() > 1) {
		var lastSketch =  $this_1.$self.getLast();
		for (var i =  0;  i < $this_1.l.size() - 1;  i++) {
		var curSketch =  $this_1.l.get(i);
		if (lastSketch.overlaps(curSketch))
		overlaps = true;
		}
		}
		return overlaps;
		}
		$p.addMethod($this_1, 'lastSketchOverlaps', lastSketchOverlaps$0);
		function mouseDragged$2(mouseX, mouseY) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.mouseDragged(mouseX, mouseY);
		}
		}
		$p.addMethod($this_1, 'mouseDragged', mouseDragged$2);
		function mouseReleased$2(mouseX, mouseY) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.mouseReleased(mouseX, mouseY);
		}
		}
		$p.addMethod($this_1, 'mouseReleased', mouseReleased$2);
		function optimize$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.optimize();
		}
		}
		$p.addMethod($this_1, 'optimize', optimize$0);
		function overSelectPoint$2(mouseX, mouseY) {
		var pointOnPlan =  new Vec2D(mouseX, mouseY);
		var p =  $this_1.$self.getClosestPathVertex(pointOnPlan);

		if (p != null && pointOnPlan.distanceTo(p) < SETTINGS_SKETCH.select_dia) {
		return true;
		} else
		return false;
		}
		$p.addMethod($this_1, 'overSelectPoint', overSelectPoint$2);
		function removeLast$0() {
		if ($this_1.l.size() > 0)
		$this_1.l.remove($this_1.l.size() - 1);

		$this_1.$self.buildOutline();
		}
		$p.addMethod($this_1, 'removeLast', removeLast$0);
		function removeVertex$1(v) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.removeVertex(v);
		}
		}
		$p.addMethod($this_1, 'removeVertex', removeVertex$1);
		function render$1(g) {
		$this_1.$self.update();


		
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.render(g);
		}
		}
		$p.addMethod($this_1, 'render', render$1);
		function renderOutline$1(g) {
		$this_1.sketchOutlines.render(g);
		}
		$p.addMethod($this_1, 'renderOutline', renderOutline$1);
		function renderPickBuffer$1(g) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.renderPickBuffer(g);
		}
		}
		$p.addMethod($this_1, 'renderPickBuffer', renderPickBuffer$1);
		function renderSide$1(g) {
		switch($this_1.$self.getParentSketch().getRenderMode()){
		case Sketch.RENDER_3D_EDITING_PLANES:
		if($this_1.$self.getParentSketch().getLayerSelected()){
		g.stroke(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_COLOUR);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_WEIGHT);

		var maxY =  $this_1.$self.getMaxY();
		var minY =  $this_1.$self.getMinY();
		var maxX =  $this_1.$self.getMaxX();

		var extrudeDepth =  ($this_1.$self.getParentSketch().getOnSketchPlane().thickness)/SETTINGS_SKETCH.scale;
		var topLayerX =  maxX;

		g.pushMatrix();
		g.beginShape();
		g.vertex(topLayerX,minY,-(extrudeDepth/2));
		g.vertex(topLayerX,minY,(extrudeDepth/2));
		g.vertex(topLayerX,maxY,(extrudeDepth/2));
		g.vertex(topLayerX,maxY,-(extrudeDepth/2));
		g.vertex(topLayerX,minY,-(extrudeDepth/2));
		g.endShape();
		g.popMatrix();
		}

		break;case Sketch.RENDER_3D_NORMAL:

		g.stroke(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_COLOUR);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_WEIGHT);

		var maxY =  $this_1.$self.getMaxY();
		var minY =  $this_1.$self.getMinY();
		var maxX =  $this_1.$self.getMaxX();

		var extrudeDepth =  ($this_1.$self.getParentSketch().getOnSketchPlane().thickness)/SETTINGS_SKETCH.scale;
		var topLayerX =  maxX;

		g.pushMatrix();
		g.beginShape();
		g.vertex(topLayerX,minY,-(extrudeDepth/2));
		g.vertex(topLayerX,minY,(extrudeDepth/2));
		g.vertex(topLayerX,maxY,(extrudeDepth/2));
		g.vertex(topLayerX,maxY,-(extrudeDepth/2));
		g.vertex(topLayerX,minY,-(extrudeDepth/2));
		g.endShape();
		g.popMatrix();

		break;
		}
		}
		$p.addMethod($this_1, 'renderSide', renderSide$1);
		function renderSilhouette$1(g) {
		$this_1.sketchOutlines.renderSilhouette(g);
		}
		$p.addMethod($this_1, 'renderSilhouette', renderSilhouette$1);
		function scale$2(scale, centre) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.scale(scale, centre);
		}
		$this_1.sketchOutlines.scale(scale, centre);
		}
		$p.addMethod($this_1, 'scale', scale$2);
		function select$0() {
		$this_1.selected = true;
		}
		$p.addMethod($this_1, 'select', select$0);
		function selectAll$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.select();
		}
		}
		$p.addMethod($this_1, 'selectAll', selectAll$0);
		function selectNodes$2(x, y) {
		var nodeFound =  false;
		var selectedNode =  null;
		var selectedNodeObj =  null;
		var nodesFoundInSketch =  null;

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.selectNodes(x, y);

		 if (curSketch.getSelectedNodes().size() > 0) {
		for (var n =  0;  n < curSketch.getSelectedNodes().size();  n++) {
		var o =  curSketch.getSelectedNodes().get(n);
		var p =   curSketch.getSelectedNodes().get(n);

		nodeFound = true;
		if (selectedNode == null
		|| p.distanceTo(new Vec2D(x, y)) < selectedNode
		.distanceTo(new Vec2D(x, y))) {
		selectedNode = p;
		selectedNodeObj = o;
		}
		}
		}

		if (nodeFound) {
		if (nodesFoundInSketch != null) {
		nodesFoundInSketch.getSelectedNodes().clear();
		}
		$this_1.$self.getParentSketch().getSelectedNodes().clear();
		curSketch.getSelectedNodes().clear();
		curSketch.getSelectedNodes().add(selectedNodeObj);
		nodesFoundInSketch = curSketch;
		}
		nodeFound = false;
		}

		if (selectedNode != null)
		$this_1.$self.getParentSketch().getSelectedNodes().add(selectedNodeObj);
		}
		$p.addMethod($this_1, 'selectNodes', selectNodes$2);
		function selectShape$2(x, y) {
		if ($this_1.selectedShape != null) {
		$this_1.selectedShape.selected = false;
		$this_1.selectedShape = null;
		}

		$this_1.$self.unSelectAll();

		 var closestShape =  null;
		var closestPoint =  null;
		var mousePos =  new Vec2D(x, y);
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		var point =  curSketch.getClosestPointAlongPath(x, y);

		if (point == null)
		return;

		if (i == 0
		|| mousePos.distanceTo(point) < mousePos
		.distanceTo(closestPoint)) {
		closestPoint = point;
		closestShape = curSketch;
		}
		}
		if (mousePos.distanceTo(closestPoint) < SETTINGS_SKETCH.select_dia
		&& closestShape != null) {
		$this_1.selectedShape = closestShape;
		$this_1.selectedShape.selected = true;
		closestShape.select();
		}
		}
		$p.addMethod($this_1, 'selectShape', selectShape$2);
		function setEditing$1(e) {
		$this_1.editing = e;
		}
		$p.addMethod($this_1, 'setEditing', setEditing$1);
		function setParentSketch$1(parentS) {
		$this_1.parentSketch = parentS;

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.setParentSketch(parentS);
		}
		}
		$p.addMethod($this_1, 'setParentSketch', setParentSketch$1);
		function setSlots$1(slots) {
		$this_1.slots = slots;
		}
		$p.addMethod($this_1, 'setSlots', setSlots$1);
		function setVec2DpickBuffer$5(col, selectedVec, selectedShape, selectedVecPlane, isSelectedVecOnOutline) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		var ret =  curSketch.setVec2DpickBuffer(col, selectedVec,
		selectedShape, selectedVecPlane, isSelectedVecOnOutline);
		if (ret != null) {
		selectedShape = curSketch;
		return ret;
		}
		}
		return null;
		}
		$p.addMethod($this_1, 'setVec2DpickBuffer', setVec2DpickBuffer$5);
		function size$0() {
		return $this_1.l.size();
		}
		$p.addMethod($this_1, 'size', size$0);
		function toXML$0() {
		var element =  new Element("SketchShapes");
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		element.appendChild(curSketch.toXML());
		}
		return element;
		}
		$p.addMethod($this_1, 'toXML', toXML$0);
		function unselect$0() {
		$this_1.selected = false;
		}
		$p.addMethod($this_1, 'unselect', unselect$0);
		function unSelectAll$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var sketch =  $this_1.l.get(i);
		sketch.unselect();
		}
		}
		$p.addMethod($this_1, 'unSelectAll', unSelectAll$0);
		function update$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);

		if (curSketch.isDestroying() == true) {
		$this_1.l.remove(i);

		if ($this_1.currentShape == curSketch) {
		if ($this_1.l.size() > 0)
		$this_1.currentShape = $this_1.l.get($this_1.l.size() - 1);
		else
		$this_1.currentShape = null;
		}

		$this_1.$self.buildOutline();
		}

		curSketch.selected = false;

		if (i == $this_1.l.size() - 1) {

		}
		}
		}
		$p.addMethod($this_1, 'update', update$0);
		function removeLegs$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		if($p.__instanceof(curSketch , SketchSpline )&& (curSketch).getType() == SketchSpline.TYPE_LEG ){
		curSketch.destroy();
		$this_1.l.remove(i);
		i--;
		}
		}
		$this_1.$self.buildOutline();
		}
		$p.addMethod($this_1, 'removeLegs', removeLegs$0);
		function setEditable$1(editable) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSketch =  $this_1.l.get(i);
		curSketch.setEditable(editable);
		}
		}
		$p.addMethod($this_1, 'setEditable', setEditable$1);
		function $constr_1(parentS){
		$superCstr();

		$this_1.$self.setParentSketch(parentS);

		$this_1.slots = new SliceSlots();
		$this_1.slots.setParentSketch(parentS);
		}

		function $constr_2(sketch, element){
		$superCstr();

		$this_1.$self.setParentSketch(sketch);
		$this_1.slots.setParentSketch(sketch);
		 if (!$p.__equals(element.getLocalName(),"SketchShapes"))
		return;

		 $this_1.selected = true;

		for (var i =  0;  i < element.getChildCount();  i++) {
		var child =   element.getChild(i);

		if (child != null && $p.__equals(child.getLocalName(),"SketchPath"))
		$this_1.$self.add(new SketchPath($this_1.$self.getParentSketch(), child));

		if (child != null && $p.__equals(child.getLocalName(),"SketchSpline"))
		$this_1.$self.add(new SketchSpline($this_1.$self.getParentSketch(), child));
		}
		}

		function $constr_2(parentS, slice){
		$superCstr();

		$this_1.$self.setParentSketch(parentS);
		$this_1.slots.setParentSketch(parentS);

		$this_1.onSlicePlane = slice;
		}

		function $constr() {
		if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		return SketchShapes;
		})();
		$p.SketchShapes = SketchShapes;
		var SketchOutlines = (function() {
		function SketchOutlines() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$this_1.l =  new $p.ArrayList();
		$this_1.parentSketchShapes =  null;
		function add$1(sktOutline) {
		$this_1.$self.getList().add(sktOutline);
		}
		$p.addMethod($this_1, 'add', add$1);
		function clear$0() {
		$this_1.$self.getList().clear();
		}
		$p.addMethod($this_1, 'clear', clear$0);
		function flipHorizontal$1(centre) {
		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var sktOutline =  $this_1.$self.getList().get(i);
		sktOutline.flipHorizontal(centre);
		}
		}
		$p.addMethod($this_1, 'flipHorizontal', flipHorizontal$1);
		function getArea$0() {
		var outerOutline =  $this_1.$self.getOutterOutline();

		if (outerOutline == null)
		return 0;

		var totalArea =  outerOutline.getArea();

		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var sktOutline =  $this_1.$self.getList().get(i);

		if (sktOutline != outerOutline)
		totalArea -= sktOutline.getArea();
		}

		return totalArea;
		}
		$p.addMethod($this_1, 'getArea', getArea$0);
		function getCentreOfMass$0() {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getCentreOfMass();
		else
		return null;
		}
		$p.addMethod($this_1, 'getCentreOfMass', getCentreOfMass$0);
		function getHeight$0() {
		var outline =  $this_1.$self.getOutterOutline();
		if (outline != null)
		return outline.getHeight();
		else
		return 0;
		}
		$p.addMethod($this_1, 'getHeight', getHeight$0);
		function getList$0() {
		return $this_1.l;
		}
		$p.addMethod($this_1, 'getList', getList$0);
		function getMaxX$0() {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getMaxX();
		else
		return -1;
		}
		$p.addMethod($this_1, 'getMaxX', getMaxX$0);
		function getMaxXWorldSpace$1(currentWorldTransform) {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getMaxXWorldSpace(currentWorldTransform);
		else
		return -1;
		}
		$p.addMethod($this_1, 'getMaxXWorldSpace', getMaxXWorldSpace$1);
		function getMaxY$0() {
		var maxY =  -1;

		var outline =  $this_1.$self.getOutterOutline();
		if (outline != null)
		maxY = outline.getMaxY();

		return maxY;
		}
		$p.addMethod($this_1, 'getMaxY', getMaxY$0);
		function getMaxYWorldSpace$1(currentWorldTransform) {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getMaxYWorldSpace(currentWorldTransform);
		else
		return -1;
		}
		$p.addMethod($this_1, 'getMaxYWorldSpace', getMaxYWorldSpace$1);
		function getMinX$0() {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getMinX();
		else
		return -1;
		}
		$p.addMethod($this_1, 'getMinX', getMinX$0);
		function getMinXWorldSpace$1(currentWorldTransform) {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getMinXWorldSpace(currentWorldTransform);
		else
		return -1;
		}
		$p.addMethod($this_1, 'getMinXWorldSpace', getMinXWorldSpace$1);
		function getMinY$0() {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getMinY();
		else
		return -1;
		}
		$p.addMethod($this_1, 'getMinY', getMinY$0);
		function getMinYWorldSpace$1(currentWorldTransform) {
		if ($this_1.$self.getOutterOutline() != null)
		return $this_1.$self.getOutterOutline().getMinYWorldSpace(currentWorldTransform);
		else
		return -1;
		}
		$p.addMethod($this_1, 'getMinYWorldSpace', getMinYWorldSpace$1);
		function getOutterOutline$0() {
		if ($this_1.$self.getList().size() > 0) {
		var foundOutline =  $this_1.$self.getList().get(
		$this_1.$self.getList().size() - 1);
		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var tempOutline =  $this_1.$self.getList().get(i);
		if (tempOutline != null && foundOutline != null
		&& tempOutline.getArea() > foundOutline.getArea())
		foundOutline = tempOutline;
		}

		return foundOutline;
		} else
		return null;
		}
		$p.addMethod($this_1, 'getOutterOutline', getOutterOutline$0);
		function getspShape$0() {
		var shape =  new spShape();
		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var sktOutline =  $this_1.$self.getList().get(i);
		sktOutline.setupSpShape(shape);
		}

		return shape;
		}
		$p.addMethod($this_1, 'getspShape', getspShape$0);
		function addCollisionToSpShape$1(shape) {
		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var sktOutline =  $this_1.$self.getList().get(i);
		sktOutline.addCollisionToSpShape(shape);
		}

		return shape;
		}
		$p.addMethod($this_1, 'addCollisionToSpShape', addCollisionToSpShape$1);
		function optimize$0() {
		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var sktOutline =  $this_1.$self.getList().get(i);
		sktOutline.optimize();
		}
		}
		$p.addMethod($this_1, 'optimize', optimize$0);
		function render$1(g) {
		g.pushMatrix();
		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var sktOutline =  $this_1.$self.getList().get(i);
		sktOutline.render(g);
		}
		g.popMatrix();
		}
		$p.addMethod($this_1, 'render', render$1);
		function renderSilhouette$1(g) {
		if($this_1.$self.getOutterOutline() == null)
		return;

		g.fill(0,0,0);

		$this_1.$self.getOutterOutline().getPath().setClosed(true);
		$this_1.$self.getOutterOutline().getPath().renderFlat(g);
		}
		$p.addMethod($this_1, 'renderSilhouette', renderSilhouette$1);
		function scale$2(scale, centre) {
		for (var i =  0;  i < $this_1.$self.getList().size();  i++) {
		var sktOutline =  $this_1.$self.getList().get(i);
		sktOutline.scale(scale, centre);
		}
		}
		$p.addMethod($this_1, 'scale', scale$2);
		function setList$1(l) {
		$this_1.l = l;
		}
		$p.addMethod($this_1, 'setList', setList$1);
		function $constr_1(sketchShapes){
		$superCstr();

		$this_1.parentSketchShapes = sketchShapes;
		}

		function $constr() {
		if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		return SketchOutlines;
		})();
		$p.SketchOutlines = SketchOutlines;
		var SliceSlots = (function() {
		function SliceSlots() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$this_1.l =  new $p.ArrayList();
		$this_1.parentSketch = null;
		function add$1(slot) {
		$this_1.l.add(slot);
		}
		$p.addMethod($this_1, 'add', add$1);
		function removeTrappedSlots$1(outlineSketch) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);
		curSlot.removeTrappedSlots(outlineSketch);
		}
		}
		$p.addMethod($this_1, 'removeTrappedSlots', removeTrappedSlots$1);
		function removeNonPiercing$1(outlineSketch) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);
		curSlot.removeNonPiercing(outlineSketch);
		}
		}
		$p.addMethod($this_1, 'removeNonPiercing', removeNonPiercing$1);
		function checkForSlotCollisions$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);
		for (var j =  0;  j < $this_1.l.size();  j++) {
		var otherSlot =  $this_1.l.get(j);

		if (curSlot != otherSlot && !curSlot.destroy
		&& !otherSlot.destroy)
		curSlot.checkForCollision(otherSlot);
		}
		}
		}
		$p.addMethod($this_1, 'checkForSlotCollisions', checkForSlotCollisions$0);
		function clone$0() {
		var newSlots =  new SliceSlots();
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);
		newSlots.l.add(curSlot.clone());
		}
		return newSlots;
		}
		$p.addMethod($this_1, 'clone', clone$0);
		function empty$0() {
		$this_1.l = new $p.ArrayList();
		}
		$p.addMethod($this_1, 'empty', empty$0);
		function get$1(k) {
		return $this_1.l.get(k);
		}
		$p.addMethod($this_1, 'get', get$1);
		function renderEdge$1(g) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);
		curSlot.renderEdge(g);
		}
		}
		$p.addMethod($this_1, 'renderEdge', renderEdge$1);
		function render$1(g) {
		$this_1.$self.update();

		  switch($this_1.$self.getParentSketch().getRenderMode()){
		case Sketch.RENDER_3D_EDITING_PLANES:
		{
		g.stroke(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_COLOUR);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_WEIGHT);
		}
		break;

		default: 
		g.stroke(SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED);
		g.strokeWeight(SETTINGS_SKETCH.SKETCHOUTLINE_UNSELECTED_WEIGHT);
		break;
		}

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);
		curSlot.render(g);
		}
		}
		$p.addMethod($this_1, 'render', render$1);
		function size$0() {
		return $this_1.l.size();
		}
		$p.addMethod($this_1, 'size', size$0);
		function update$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);

		if (curSlot.destroy || curSlot.slice == null
		|| curSlot.slice.destroy == true) {
		$this_1.l.remove(i);
		}
		}
		}
		$p.addMethod($this_1, 'update', update$0);
		function removeIntersecting$0() {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curSlot =  $this_1.l.get(i);

		for (var i2 =  0;  i2 < $this_1.l.size();  i2++) {
		var otherSlot =  $this_1.l.get(i2);

		if(!$p.__equals(curSlot,otherSlot)){
		var curSlotPath =  new SketchPath(curSlot.slice.getSketch(),curSlot.getOutline(0, curSlot.slotLen*2));
		var otherSlotPath =  new SketchPath(otherSlot.slice.getSketch(),otherSlot.getOutline(0, otherSlot.slotLen*2));
		curSlotPath.setClosed(true);
		otherSlotPath.setClosed(true);
		curSlotPath.build();
		otherSlotPath.build();

		if(curSlotPath.intersects(otherSlotPath)){
		if(otherSlot.slice.tiedToLeg){
		curSlot.slice.destroy();
		curSlot.destroy();
		i2 = $this_1.l.size();
		}else{
		otherSlot.slice.destroy();
		otherSlot.destroy();
		}
		}
		}
		}
		}
		}
		$p.addMethod($this_1, 'removeIntersecting', removeIntersecting$0);
		function setParentSketch$1(sketch) {
		$this_1.parentSketch = sketch;
		}
		$p.addMethod($this_1, 'setParentSketch', setParentSketch$1);
		function getParentSketch$0() {
		return $this_1.parentSketch;
		}
		$p.addMethod($this_1, 'getParentSketch', getParentSketch$0);
		function $constr() {
		$superCstr();
		}
		$constr.apply(null, arguments);
		}
		return SliceSlots;
		})();
		$p.SliceSlots = SliceSlots;
		var Test = (function() {
		function Test() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$p.defineProperty($this_1, 'OFFSET', {get: function(){return Test.OFFSET}, set: function(val){Test.OFFSET = val}});
		function hello$3(g, x, y) {
		g.noFill();
		g.ellipse(x,y,100,100);
		}
		$p.addMethod($this_1, 'hello', hello$3);
		function $constr() {
		$superCstr();
		}
		$constr.apply(null, arguments);
		}
		Test.OFFSET =  2;
		return Test;
		})();
		$p.Test = Test;
		var SketchGlobals = (function() {
		function SketchGlobals() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$this_1.renderVolume =  false;
		$this_1.renderScreenshot =  false;
		$this_1.zoom =  1;
		$this_1.physicsEngineScale =  1;
		$this_1.seperate_slots =  false;
		$this_1.chairColour =  200;
		$this_1.undo = null;
		$this_1.sketch_id =  0;
		$this_1.BEZIER_DETAIL_OFFSET =  0.01;
		$this_1.BEZIER_DETAIL_CALCULATIONS =  0.001;
		$this_1.mousePressed = false;
		$this_1.TOUCH_SCREEN_MODE =  false;
		$this_1.extendSlots =  0;
		$this_1.slotPierceLen =  10;
		function $constr() {
		$superCstr();
		}
		$constr.apply(null, arguments);
		}
		return SketchGlobals;
		})();
		$p.SketchGlobals = SketchGlobals;
		var SketchPoint = (function() {
		function SketchPoint() {
		var $this_1 = this;
		var $super = { $upcast: $this_1 };
		function $superCstr(){Vec2D.apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}
		$this_1.controlPoint1 =  null;
		$this_1.controlPoint2 =  null;
		$this_1.isOver =  false;
		$this_1.smooth = false;
		function clone$0() {
		var returnPoint =  new SketchPoint($this_1.x, $this_1.y);

		if ($this_1.controlPoint1 != null)
		returnPoint.controlPoint1 = new Vec2D($this_1.controlPoint1.x,
		$this_1.controlPoint1.y);

		if ($this_1.controlPoint2 != null)
		returnPoint.controlPoint2 = new Vec2D($this_1.controlPoint2.x,
		$this_1.controlPoint2.y);
		return returnPoint;
		}
		$p.addMethod($this_1, 'clone', clone$0);
		function containsBezier$0() {
		if ($this_1.controlPoint2 != null || $this_1.controlPoint1 != null)
		return true;
		else
		return false;
		}
		$p.addMethod($this_1, 'containsBezier', containsBezier$0);
		function getControlPoint1$0() {
		if ($this_1.controlPoint1 == null)
		return new Vec2D($this_1.x, $this_1.y);
		else
		return $this_1.controlPoint1;
		}
		$p.addMethod($this_1, 'getControlPoint1', getControlPoint1$0);
		function getControlPoint2$0() {
		if ($this_1.controlPoint2 == null)
		return new Vec2D($this_1.x, $this_1.y);
		else
		return $this_1.controlPoint2;
		}
		$p.addMethod($this_1, 'getControlPoint2', getControlPoint2$0);
		function removeBezier$0() {
		$this_1.controlPoint1 = null;
		$this_1.controlPoint2 = null;
		}
		$p.addMethod($this_1, 'removeBezier', removeBezier$0);
		function toXML$0() {
		var element =  new Element("SketchPoint");
		element.addAttribute(new Attribute("x", String.valueOf($this_1.x)));
		element.addAttribute(new Attribute("y", String.valueOf($this_1.y)));

		if ($this_1.controlPoint1 != null) {
		element.addAttribute(new Attribute("c1x", String
		.valueOf($this_1.controlPoint1.x)));
		element.addAttribute(new Attribute("c1y", String
		.valueOf($this_1.controlPoint1.y)));
		}

		if ($this_1.controlPoint2 != null) {
		element.addAttribute(new Attribute("c2x", String
		.valueOf($this_1.controlPoint2.x)));
		element.addAttribute(new Attribute("c2y", String
		.valueOf($this_1.controlPoint2.y)));
		}

		return element;
		}
		$p.addMethod($this_1, 'toXML', toXML$0);
		function sub$1(p) {
		return p;
		}
		$p.addMethod($this_1, 'sub', sub$1);
		function $constr_1(element){
		$superCstr();

		if (!$p.__equals(element.getLocalName(),"SketchPoint"))
		return;

		if (element.getAttributeValue("x") != null)
		$this_1.x = Float.valueOf(element.getAttributeValue("x"));

		if (element.getAttributeValue("y") != null)
		$this_1.y = Float.valueOf(element.getAttributeValue("y"));

		if (element.getAttributeValue("c1x") != null
		&& element.getAttributeValue("c1x") != null) {
		var xmlC1X =  Float.valueOf(element.getAttributeValue("c1x"));
		var xmlC1Y =  Float.valueOf(element.getAttributeValue("c1y"));
		$this_1.controlPoint1 = new Vec2D(xmlC1X, xmlC1Y);
		}

		if (element.getAttributeValue("c2x") != null
		&& element.getAttributeValue("c2x") != null) {
		var xmlC2X =  Float.valueOf(element.getAttributeValue("c2x"));
		var xmlC2Y =  Float.valueOf(element.getAttributeValue("c2y"));
		$this_1.controlPoint2 = new Vec2D(xmlC2X, xmlC2Y);
		}
		}

		function $constr_2(x, y){
		$superCstr(x, y);
		}

		function $constr_1(vec){
		$superCstr();

		$this_1.x = vec.x;
		$this_1.y = vec.y;
		}

		function $constr() {
		if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		$p.extendStaticMembers(SketchPoint, Vec2D);
		SketchPoint.$base = Vec2D;
		return SketchPoint;
		})();
		$p.SketchPoint = SketchPoint;
		var SketchSpline = (function() {
		function SketchSpline() {
		var $this_1 = this;
		var $super = { $upcast: $this_1 };
		function $superCstr(){SketchShape.apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}
		$this_1.path = null;
		$this_1.centrePath = null;
		$p.defineProperty($this_1, 'TYPE_LEG', {get: function(){return SketchSpline.TYPE_LEG}, set: function(val){SketchSpline.TYPE_LEG = val}});
		$p.defineProperty($this_1, 'CAP_ROUND', {get: function(){return SketchSpline.CAP_ROUND}, set: function(val){SketchSpline.CAP_ROUND = val}});
		$p.defineProperty($this_1, 'CAP_BUTT', {get: function(){return SketchSpline.CAP_BUTT}, set: function(val){SketchSpline.CAP_BUTT = val}});
		$p.defineProperty($this_1, 'CAP_SQUARE', {get: function(){return SketchSpline.CAP_SQUARE}, set: function(val){SketchSpline.CAP_SQUARE = val}});
		$p.defineProperty($this_1, 'CAP_PARRALEL', {get: function(){return SketchSpline.CAP_PARRALEL}, set: function(val){SketchSpline.CAP_PARRALEL = val}});
		$p.defineProperty($this_1, 'CAP_LEG', {get: function(){return SketchSpline.CAP_LEG}, set: function(val){SketchSpline.CAP_LEG = val}});
		$p.defineProperty($this_1, 'JOIN_BEVEL', {get: function(){return SketchSpline.JOIN_BEVEL}, set: function(val){SketchSpline.JOIN_BEVEL = val}});
		$p.defineProperty($this_1, 'JOIN_MITER', {get: function(){return SketchSpline.JOIN_MITER}, set: function(val){SketchSpline.JOIN_MITER = val}});
		$p.defineProperty($this_1, 'JOIN_ROUND', {get: function(){return SketchSpline.JOIN_ROUND}, set: function(val){SketchSpline.JOIN_ROUND = val}});
		$p.defineProperty($this_1, 'OFFSET_LEFT', {get: function(){return SketchSpline.OFFSET_LEFT}, set: function(val){SketchSpline.OFFSET_LEFT = val}});
		$p.defineProperty($this_1, 'OFFSET_RIGHT', {get: function(){return SketchSpline.OFFSET_RIGHT}, set: function(val){SketchSpline.OFFSET_RIGHT = val}});
		$p.defineProperty($this_1, 'OFFSET_BOTH', {get: function(){return SketchSpline.OFFSET_BOTH}, set: function(val){SketchSpline.OFFSET_BOTH = val}});
		$this_1.capType =  SketchSpline.CAP_ROUND;
		$this_1.joinType =  SketchSpline.JOIN_BEVEL;
		$this_1.outineLeft =  new $p.ArrayList();
		$this_1.outineRight =  new $p.ArrayList();
		$this_1.outlineOffset =  new Hashtable();
		$this_1.centreOffset =  new Hashtable();
		$this_1.id =  0;
		$this_1.selected =  true;
		$this_1.autoSmooth =  true;
		$this_1.isOptimized = false;
		$this_1.pointDist =  5;
		$this_1.offsetSize =  20;
		$this_1.slots =  new SliceSlots();
		$this_1.slots_on_inside =  true;
		$this_1.offsetType =  2;
		$this_1.isBuilt =  false;
		$this_1.getSelectedNodes = null;
		$this_1.legClickedOn = false;
		$this_1.cacheLength = false;
		$this_1.cachedLength = 0;
		function add$1(newVec) {
			
			
		if ($this_1.$self.getCentrePath().size() < 2
		|| $this_1.$self.getLast().distanceTo(newVec) > 10) {
				$this_1.$self.getCentrePath().add(newVec);

		if (SETTINGS_SKETCH.dynamic_offset)
		$this_1.$self.offset();
		
		}
		}
		$p.addMethod($this_1, 'add', add$1);
		function addDynamicOffset$1(newVec) {
		if ($this_1.$self.getCentrePath().size() == 3)
		$this_1.$self.offset();

		if ($this_1.$self.getCentrePath().size() > 3) {
		var tempOffset =  $this_1.$self.getOffsetSize();
		var lenCurVec =  $this_1.$self.getLenTo(newVec);
		if (lenCurVec <= $this_1.$self.getOffsetSize()) {
		tempOffset = ($this_1.$self.getOffsetSize() * ( Math
		.sqrt(1 - ((1 - (lenCurVec / $this_1.$self.getOffsetSize())) * (1 - (lenCurVec / $this_1.$self.getOffsetSize()))))));
		} else {
		tempOffset = $this_1.$self.getOffsetSize();
		}

		if ($this_1.offsetType == SketchSpline.OFFSET_LEFT) {
		$this_1.outineLeft
		.add( $this_1.$self.getPerp(
		 (Math.PI / 2),
		tempOffset,
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 1),
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 3)));
		$this_1.outineRight.add( newVec);
		}

		if ($this_1.offsetType == SketchSpline.OFFSET_RIGHT) {
		$this_1.outineLeft.add( newVec);
		$this_1.outineRight
		.add( $this_1.$self.getPerp(
		 (-Math.PI / 2),
		tempOffset,
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 1),
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 3)));
		}

		if ($this_1.offsetType == SketchSpline.OFFSET_BOTH) {
		$this_1.outineLeft
		.add( $this_1.$self.getPerp(
		 (Math.PI / 2),
		tempOffset,
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 1),
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 3)));
		$this_1.outineRight
		.add( $this_1.$self.getPerp(
		 (-Math.PI / 2),
		tempOffset,
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 1),
		 $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 3)));
		}
		}
		}
		$p.addMethod($this_1, 'addDynamicOffset', addDynamicOffset$1);
		function addOffset$1(newVec) {
		var v =  new toxi.geom.Vec3D(newVec.x, newVec.y, 0);
		$this_1.outineLeft.add( newVec);
		}
		$p.addMethod($this_1, 'addOffset', addOffset$1);
		function applyOutlineOffset$0() {
		if ($this_1.$self.getCentrePath().size() == 2)
		$this_1.path.editable = true;
		else
		$this_1.path.editable = false;

		if ($this_1.$self.getCentrePath().size() > 2)
		return;

		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);

		if ($this_1.outlineOffset.containsKey(i) && $this_1.path.size() >= i) {
		if ($this_1.path.size() > i) {
		var outline =   $this_1.path.get(i);
		var offset =  $this_1.outlineOffset.get(i);
		outline.x = curVec.sub(offset).x;
		outline.y = curVec.sub(offset).y;
		}
		}
		}

		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);
		var i2 =  (($this_1.$self.getCentrePath().size() * 2) - i - 1);
		if ($this_1.outlineOffset.containsKey(i2) && $this_1.path.size() >= i2) {
		if ($this_1.path.size() >= i2) {
		var outline =   $this_1.path.get(i2);
		var offset =  $this_1.outlineOffset.get(i2);
		outline.x = curVec.sub(offset).x;
		outline.y = curVec.sub(offset).y;
		}
		}
		}
		}
		$p.addMethod($this_1, 'applyOutlineOffset', applyOutlineOffset$0);
		function build$0() {
		$this_1.$self.offset();
		}
		$p.addMethod($this_1, 'build', build$0);
		function buildPath$0() {
		$this_1.path.reset();

		for (var i =  0;  i < $this_1.$self.getCombinedSize();  i++) {
		var curVec =   $this_1.$self.getCombined(i);
		$this_1.path.add(curVec);
		}
		}
		$p.addMethod($this_1, 'buildPath', buildPath$0);
		function clone$0() {
		var newSpline =  new SketchSpline($this_1.$self.getParentSketch());
		newSpline.setType($this_1.$self.getType());
		newSpline.setCap($this_1.$self.getCap());
		newSpline.setJoinType($this_1.$self.getJoinType());

		if ($this_1.$self.getCentrePath() != null)
		newSpline.setCentrePath($this_1.$self.getCentrePath().clone());

		for (var i =  0;  i < $this_1.outineLeft.size();  i++) {
		var curVec =  $this_1.outineLeft.get(i);
		newSpline.outineLeft.add(new SketchPoint(curVec.x, curVec.y));
		}

		for (var i =  0;  i < $this_1.outineRight.size();  i++) {
		var curVec =  $this_1.outineRight.get(i);
		newSpline.outineRight.add(new SketchPoint(curVec.x, curVec.y));
		}

		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		if ($this_1.$self.getCentreOffset().get(i) != null)
		newSpline.getCentreOffset().put(i,
		$this_1.$self.getCentreOffset().get(i));
		}

		newSpline.slots = $this_1.slots.clone();

		newSpline.setOffsetSize($this_1.$self.getOffsetSize());
		newSpline.path = $this_1.path.clone();
		newSpline.isBuilt = $this_1.isBuilt;
		newSpline.offsetType = $this_1.offsetType;
		newSpline.path.editable = $this_1.path.editable;
		newSpline.setClosed($this_1.$self.getClosed());
		 return newSpline;
		}
		$p.addMethod($this_1, 'clone', clone$0);
		function copy$1(parentSketch) {
		var newSketchSpline =  new SketchSpline(parentSketch);

		newSketchSpline.setId($this_1.$self.getId());
		newSketchSpline.path.setId($this_1.path.getId());
		newSketchSpline.getCentrePath().setId($this_1.$self.getCentrePath().getId());

		newSketchSpline.offsetSize = $this_1.offsetSize;
		newSketchSpline.setType($this_1.$self.getType());
		newSketchSpline.setCap($this_1.$self.getCap());
		newSketchSpline.setJoinType($this_1.$self.getJoinType());

		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var skPoint =   $this_1.$self.getCentrePath().get(i);
		var skPointCopy =  skPoint.clone();
		newSketchSpline.getCentrePath().add(skPointCopy);
		if ($this_1.$self.getCentreOffset().containsKey(i)) {
		newSketchSpline.getCentreOffset().put(i,
		$this_1.$self.getCentreOffset().get(i));
		}
		}

		newSketchSpline.setClosed($this_1.$self.getClosed());

		return newSketchSpline;
		}
		$p.addMethod($this_1, 'copy', copy$1);
		function countSelectedNodes$0() {
		return $this_1.getSelectedNodes().size() + $this_1.path.countSelectedNodes();
		}
		$p.addMethod($this_1, 'countSelectedNodes', countSelectedNodes$0);
		function destroy$0() {
		$this_1.$self.setDestroy(true);

		if ($this_1.$self.getCentrePath() != null)
		$this_1.$self.getCentrePath().setDestroy(true);
		}
		$p.addMethod($this_1, 'destroy', destroy$0);
		function flipHorizontal$1(centre) {
		$this_1.$self.getCentrePath().flipHorizontal(centre);
		$this_1.path.flipHorizontal(centre);
		}
		$p.addMethod($this_1, 'flipHorizontal', flipHorizontal$1);
		function getCap$0() {
		return $this_1.capType;
		}
		$p.addMethod($this_1, 'getCap', getCap$0);
		function getCentreOffset$0() {
		return $this_1.centreOffset;
		}
		$p.addMethod($this_1, 'getCentreOffset', getCentreOffset$0);
		function getCentreOfMass$0() {
		var x =  0;
		var y =  0;

		for (var i =  0;  i < $this_1.$self.getCombinedSize();  i++) {
		var v =   $this_1.$self.getCombined(i);
		x += v.x;
		y += v.y;
		}
		return new Vec2D(x / $this_1.$self.getCombinedSize(), y / $this_1.$self.getCombinedSize());
		}
		$p.addMethod($this_1, 'getCentreOfMass', getCentreOfMass$0);
		function getCentrePath$0() {
		return $this_1.centrePath;
		}
		$p.addMethod($this_1, 'getCentrePath', getCentrePath$0);
		function getClosestPercent$2(mouseX, mouseY) {
		return $this_1.path.getClosestPercent(mouseX, mouseY);
		}
		$p.addMethod($this_1, 'getClosestPercent', getClosestPercent$2);
		function getClosestPoint$1(pointOnPlan) {
		return $this_1.$self.getCentrePath().getClosestPoint(pointOnPlan);
		}
		$p.addMethod($this_1, 'getClosestPoint', getClosestPoint$1);
		function getClosestPoint$1_2(pointOnPlan) {
		return $this_1.$self.getCentrePath().getClosestPoint(pointOnPlan);
		}
		$p.addMethod($this_1, 'getClosestPoint', getClosestPoint$1_2);
		function getClosestPointAlongPath$2(x, y) {
		var mPos =  new Vec2D(x, y);
		var centreP =  $this_1.$self.getCentrePath().getClosestPointAlongPath(x, y);
		var outlineP =  $this_1.$self.getPath().getClosestPointAlongPath(x, y);

		if (mPos == null || centreP == null || outlineP == null)
		return null;

		if (centreP.distanceTo(mPos) < outlineP.distanceTo(mPos))
		return centreP;
		else
		return outlineP;
		}
		$p.addMethod($this_1, 'getClosestPointAlongPath', getClosestPointAlongPath$2);
		function getColor$1(id) {
		return -(id + 2);
		}
		$p.addMethod($this_1, 'getColor', getColor$1);
		function getCombined$1(i) {
		if (i < $this_1.outineRight.size())
		return $this_1.outineRight.get(i);
		else
		return $this_1.outineLeft.get($this_1.outineLeft.size()
		- (i - $this_1.outineRight.size()) - 1);
		}
		$p.addMethod($this_1, 'getCombined', getCombined$1);
		function getCombinedSize$0() {
		return $this_1.outineRight.size() + $this_1.outineLeft.size();
		}
		$p.addMethod($this_1, 'getCombinedSize', getCombinedSize$0);
		function getDistBetween$2(first, second) {
		var length =  0;

		if (first == second)
		return length;

		var startVec =  null;

		for (var i =  0;  i < $this_1.$self.getCentrePath().size() - 1;  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);
		var nextVec =   $this_1.$self.getCentrePath().get(i + 1);

		if (startVec == null && (curVec == first || curVec == second))
		startVec = curVec;

		if (startVec != null)
		length += curVec.distanceTo(nextVec);

		if (startVec != null && (nextVec == first || nextVec == second))
		return length;
		}
		return length;
		}
		$p.addMethod($this_1, 'getDistBetween', getDistBetween$2);
		function getFirst$0() {
		if ($this_1.$self.getCentrePath().size() > 0)
		return  $this_1.$self.getCentrePath().get(0);
		else
		return null;
		}
		$p.addMethod($this_1, 'getFirst', getFirst$0);
		function getIndex$1(startVec) {
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var vec =   $this_1.$self.getCentrePath().get(i);
		if (startVec == vec)
		return i;
		}

		return -1;
		}
		$p.addMethod($this_1, 'getIndex', getIndex$1);
		function getJoinType$0() {
		return $this_1.joinType;
		}
		$p.addMethod($this_1, 'getJoinType', getJoinType$0);
		function getLast$0() {
		if ($this_1.$self.getCentrePath().size() > 0)
		return  $this_1.$self.getCentrePath()
		.get($this_1.$self.getCentrePath().size() - 1);
		else
		return null;
		}
		$p.addMethod($this_1, 'getLast', getLast$0);
		function getlength$0() {
		var length =  0;

		for (var i =  0;  i < $this_1.$self.getCentrePath().size() - 1;  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);
		var nextVec =   $this_1.$self.getCentrePath().get(i + 1);

		if (curVec != null && nextVec != null)
		length += curVec.distanceTo(nextVec);
		}

		return length;
		}
		$p.addMethod($this_1, 'getlength', getlength$0);
		function getLength$0() {
		return $this_1.$self.getCentrePath().size();
		}
		$p.addMethod($this_1, 'getLength', getLength$0);
		function getLenTo$1(curVecC) {
		var length =  0;

		if (curVecC == null)
		return -1;

		for (var i =  0;  i < $this_1.$self.getCentrePath().size() - 1;  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);
		var nextVec =   $this_1.$self.getCentrePath().get(i + 1);

		if (curVecC != nextVec && curVecC != curVec && nextVec != null)
		length += curVec.distanceTo(nextVec);
		else
		return length;
		}
		return -1;
		}
		$p.addMethod($this_1, 'getLenTo', getLenTo$1);
		function getNearestVec$1(selectedNode) {
		var foundVec =  null;
		var dist =  0;

		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var vec =   $this_1.$self.getCentrePath().get(i);
		if (vec.distanceTo(selectedNode) < dist || foundVec == null) {
		dist = vec.distanceTo(selectedNode);
		foundVec = vec;
		}
		}

		return foundVec;
		}
		$p.addMethod($this_1, 'getNearestVec', getNearestVec$1);
		function getNearestVecIndex$1(selectedNode) {
		var index =  -1;
		var dist =  0;

		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var vec =   $this_1.$self.getCentrePath().get(i);
		if (vec.distanceTo(selectedNode) < dist || index == -1) {
		dist = vec.distanceTo(selectedNode);
		index = i;
		}
		}

		return index;
		}
		$p.addMethod($this_1, 'getNearestVecIndex', getNearestVecIndex$1);
		function getOffsetSize$0() {
		return $this_1.offsetSize;
		}
		$p.addMethod($this_1, 'getOffsetSize', getOffsetSize$0);
		function getOffsetSize$1_2(percent) {
		var startNodeIndex =  $this_1.$self.getCentrePath().getPosIndex(percent);
		var startNodePercent =  $this_1.$self.getCentrePath().getPercent(
		$this_1.$self.getCentrePath().get(startNodeIndex));
		var endNodePercent =  $this_1.$self.getCentrePath().getPercent(
		$this_1.$self.getCentrePath().get(startNodeIndex + 1));
		var currentSegPercent =  (endNodePercent - startNodePercent);
		var betweenPercent =  (percent - startNodePercent) / currentSegPercent;

		var thisOffset =  $this_1.$self.getOffsetSize();
		var nextOffset =  $this_1.$self.getOffsetSize();

		if ($this_1.$self.getCentreOffset().containsKey(startNodeIndex))
		thisOffset = $this_1.$self.getCentreOffset().get(startNodeIndex);

		if ($this_1.$self.getCentreOffset().containsKey(startNodeIndex + 1))
		nextOffset = $this_1.$self.getCentreOffset().get(startNodeIndex + 1);

		return (thisOffset * (1 - betweenPercent))
		+ (nextOffset * (betweenPercent));
		}
		$p.addMethod($this_1, 'getOffsetSize', getOffsetSize$1_2);
		function getOutlineGeneralPath$0() {
		return $this_1.path.getOutlineGeneralPath();
		}
		$p.addMethod($this_1, 'getOutlineGeneralPath', getOutlineGeneralPath$0);
		function getOverShape$2(x, y) {
		var closePoint =  $this_1.path.getClosestPointAlongPath(x, y);
		var closePointCentre =  $this_1.$self.getCentrePath().getClosestPointAlongPath(
		x, y);

		var distToClosePoint =  0;
		var distToClosePointCentre =  0;

		if (closePoint != null)
		distToClosePoint = closePoint.distanceTo(new Vec2D(x, y));

		if (closePointCentre != null)
		distToClosePointCentre = closePointCentre
		.distanceTo(new Vec2D(x, y));

		if (closePoint != null && (distToClosePoint <= distToClosePointCentre)
		&& distToClosePoint < SETTINGS_SKETCH.SELECT_EDGE_DIST) {
		$this_1.path.lastMouseOverVec = closePoint;
		$this_1.path.lastMouseOverPercent = $this_1.path.getClosestPercent(x, y);
		return $this_1.path;
		}

		closePoint = $this_1.$self.getCentrePath().getClosestPointAlongPath(x, y);

		if (closePoint != null && (distToClosePointCentre < distToClosePoint)
		&& distToClosePointCentre < SETTINGS_SKETCH.SELECT_EDGE_DIST) {
		$this_1.lastMouseOverVec = closePoint;
		$this_1.lastMouseOverPercent = $this_1.$self.getCentrePath().getClosestPercent(
		x, y);
		return $this_1.$self;
		}

		return null;
		}
		$p.addMethod($this_1, 'getOverShape', getOverShape$2);
		function getPath$0() {
		return $this_1.path;
		}
		$p.addMethod($this_1, 'getPath', getPath$0);
		function getPerp$4(angle, offsetDelta, vec1, vec2) {
		var curVec2 =  vec1; var prevVec =  vec2; var curAnNext =  curVec2.sub(prevVec);
		curAnNext.normalize();
		var newAn =  curAnNext.getRotated(angle);
		newAn.normalize();
		newAn.scaleSelf(offsetDelta);
		newAn.addSelf(curVec2);
		return new SketchPoint(newAn.x, newAn.y);
		}
		$p.addMethod($this_1, 'getPerp', getPerp$4);
		function getPerpendicular$1(percent) {
		return $this_1.$self.getCentrePath().getPerpendicular(percent);
		}
		$p.addMethod($this_1, 'getPerpendicular', getPerpendicular$1);
		function getPos$1(percent) {
		return $this_1.$self.getCentrePath().getPos(percent);
		}
		$p.addMethod($this_1, 'getPos', getPos$1);
		function getSelectedNodes$0() {
		return $this_1.$self.getCentrePath().getSelectedNodes();
		}
		$p.addMethod($this_1, 'getSelectedNodes', getSelectedNodes$0);
		function getSketchPointpickBuffer$1(col) {
		return null;
		}
		$p.addMethod($this_1, 'getSketchPointpickBuffer', getSketchPointpickBuffer$1);
		function getVec2DpickBuffer$1(col) {
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);
		if (col == $this_1.$self.getColor(i + ($this_1.id * 100)))
		return curVec;
		}

		for (var i =  0;  i < $this_1.path.size();  i++) {
		var curVec =   $this_1.path.get(i);

		if (col == $this_1.$self.getColor($this_1.$self.getCentrePath().size() + i + ($this_1.id * 100))) {
		return curVec;
		}
		}

		return null;
		}
		$p.addMethod($this_1, 'getVec2DpickBuffer', getVec2DpickBuffer$1);
		function insertPoint$1(closestPoint) {
		$this_1.$self.getCentrePath().insertPoint(closestPoint);
		}
		$p.addMethod($this_1, 'insertPoint', insertPoint$1);
		function isPointInside$1(p) {
		return $this_1.path.isPointInside(p);
		}
		$p.addMethod($this_1, 'isPointInside', isPointInside$1);
		function mouseDragged$2(mouseX, mouseY) {
		var pointOnPlane =  new Vec2D(mouseX, mouseY);

		if ($this_1.path.editable)
		$this_1.path.mouseDragged(mouseX, mouseY);

		if ($this_1.$self.getParentSketch().getSketchTools().getCurrentTool() == SketchTools.SELECT_TOOL) {
		for (var i =  0;  i < $this_1.$self.getSelectedNodes().size();  i++) {
		var v =   $this_1.$self.getSelectedNodes().get(i);

		if ($this_1.$self.getType() == SketchShape.TYPE_SPLINE)
		$this_1.$self.movePointFalloff(v, pointOnPlane);

		if ($this_1.$self.getType() == SketchShape.OFFSET_SPLINE)
		$this_1.$self.movePoint(v, pointOnPlane);

		if ($this_1.$self.getCentrePath().size() == 2)
		$this_1.legClickedOn = true;
		}

		for (var i =  0;  i < $this_1.$self.getSelectedNodes().size();  i++) {
		var v =   $this_1.$self.getSelectedNodes().get(i);

		if ($p.__instanceof(v , SketchPoint)) {
		$this_1.$self.movePoint( v, pointOnPlane);
		} else if ($p.__instanceof(v , Vec2D))
		$this_1.$self.movePoint( v, pointOnPlane);
		}
		}

		$this_1.$self.getCentrePath().mouseDragged(mouseX, mouseY);

		if ($this_1.$self.getSelectedNodes().size() > 0
		|| $this_1.$self.getCentrePath().getSelectedNodes().size() > 0)
		$this_1.$self.offset();
		}
		$p.addMethod($this_1, 'mouseDragged', mouseDragged$2);
		function mouseReleased$2(mouseX, mouseY) {
		$this_1.$self.optimize();
		$this_1.legClickedOn = false;

		 if($this_1.centrePath.size() <= 1){
		$this_1.$self.destroy();
		LOGGER.info("destroy");
		}
		}
		$p.addMethod($this_1, 'mouseReleased', mouseReleased$2);
		function movePoint$2(selectedVec, planePoint) {
		if (selectedVec.containsBezier()) {

		}
		}
		$p.addMethod($this_1, 'movePoint', movePoint$2);
		function movePoint$2_2(v, planePoint) {

		}
		$p.addMethod($this_1, 'movePoint', movePoint$2_2);
		function movePointFalloff$2(selectVec, pointOnPlane) {
		if ($this_1.$self.getCentrePath().size() <= 2)
		return;

		var diff =  pointOnPlane.sub(selectVec);
		var startVec =  null;
		var endVec =  null;
		var lastVec =  null;

		var pointIndex =  $this_1.$self.getIndex(selectVec);

		if (pointIndex == 0) {
		selectVec.set(pointOnPlane);

		if (startVec == null)
		startVec = selectVec;

		if (startVec != null && $this_1.$self.getCentrePath().size() > 3)
		endVec =  $this_1.$self.getCentrePath().get(3);
		else
		endVec =  $this_1.$self.getCentrePath()
		.get($this_1.$self.getCentrePath().size() - 1);
		} else if (pointIndex == $this_1.$self.getCentrePath().size() - 1) {
		selectVec.set(pointOnPlane);

		if ($this_1.$self.getCentrePath().size() > 1) {
		var v =   $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 2);

		v.x += diff.scale(.2).x;
		v.y += diff.scale(.2).y;
		}

		if (startVec == null && $this_1.$self.getCentrePath().size() > 3)
		startVec =  $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 3);
		else
		startVec =  $this_1.$self.getCentrePath().get(0);

		if (startVec != null)
		endVec = selectVec;
		} else {
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var v =   $this_1.$self.getCentrePath().get(i);

		var dist =  $this_1.$self.getDistBetween(v, selectVec);
		var fieldDia =  SETTINGS_SKETCH.splineMoveFalloff * (1 / $this_1.$self.getParentSketch().getZOOM());
		var delta =  (fieldDia - dist) / fieldDia;

		if (dist < fieldDia) {
		var scale =   Math.sin(((Math.PI / 2) * delta));
		var shapedDiff =  diff.scale(scale);

		 v.x += shapedDiff.x;
		v.y += shapedDiff.y;

		if (startVec == null)
		startVec = v;

		if (startVec != null)
		endVec = v;
		}
		}
		}

		$this_1.$self.optimizeRange(startVec, endVec);
		}
		$p.addMethod($this_1, 'movePointFalloff', movePointFalloff$2);
		function offset$0() {
		if ($this_1.$self.getCentrePath().size() < 2)
		return;

		var offsetSize1 =  0;
		var offsetSize2 =  0;

		if ($this_1.$self.getCentreOffset().get(1) != null)
		offsetSize1 = $this_1.$self.getCentreOffset().get(1);

		if ($this_1.$self.getCentreOffset().get(0) != null)
		offsetSize2 = $this_1.$self.getCentreOffset().get(0);

		if (offsetSize2 == 0)
		offsetSize2 = $this_1.$self.getOffsetSize();

		$this_1.outineLeft = new $p.ArrayList();
		$this_1.outineRight = new $p.ArrayList();

		var tempOffset =  $this_1.$self.getOffsetSize();
		var tempOffsetNext =  tempOffset;

		 for (var i = 0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curveNormal1 =  null;
		var curveNormal2 =  null;

		var curveNormalPrev1 =  null;
		var curveNormalPrev2 =  null;

		var prevVec =  null;
		var nextVec =  null;
		var curVec =  null;
		var curPoint =  null;
		var nextPoint =  null;
		var prevPoint =  null;
		
		curVec =  $this_1.$self.getCentrePath().get(i);
		curPoint = $this_1.$self.getCentrePath().get(i);

		if (curVec == null)
		break;
		
		if (i == 0 && i < $this_1.$self.getCentrePath().size()) {
		nextVec =  $this_1.$self.getCentrePath().get(i + 1);
		nextPoint = $this_1.$self.getCentrePath().get(i + 1);
		curveNormal2 =  nextVec.sub(curVec).copy().normalize();
		} else if (i > $this_1.$self.getCentrePath().size() - 2) {
		prevVec =  $this_1.$self.getCentrePath().get(i - 1);
		prevPoint = $this_1.$self.getCentrePath().get(i - 1);
		curveNormal1 = curVec.sub( prevVec).copy().normalize();
		} else {
		prevVec =  $this_1.$self.getCentrePath().get(i - 1);
		nextVec =  $this_1.$self.getCentrePath().get(i + 1);
		nextPoint = $this_1.$self.getCentrePath().get(i + 1);
		prevPoint = $this_1.$self.getCentrePath().get(i - 1);

		if (nextVec == null)
		nextVec = curVec;

		var curAnPrev =  curVec.sub(prevVec).copy();
		var curAnNext =  nextVec.sub(curVec).copy();

		curAnPrev.normalize();
		curAnNext.normalize();

		curveNormal1 = curAnPrev;
		curveNormal2 = curAnNext;
		
		console.log(curveNormal2.x + " " +  curveNormal2.y);
		}

		
		
		
		
		
		tempOffset = $this_1.$self.getOffsetSize();
		tempOffsetNext = $this_1.$self.getOffsetSize();

		if ($this_1.$self.getCentreOffset().containsKey(i))
		tempOffset = $this_1.$self.getCentreOffset().get(i);

		if (nextPoint != null && $this_1.$self.getCentreOffset().containsKey(i + 1)) {
		tempOffsetNext = $this_1.$self.getCentreOffset().get(i + 1);
		}

		if (prevPoint != null && prevPoint.controlPoint2 != null
		&& !$p.__equals(prevPoint.controlPoint2,prevPoint)) {
		prevVec = prevPoint.controlPoint2;
		curveNormal1 = curVec.sub( prevVec).normalize();
		}

		if (nextPoint != null && nextPoint.controlPoint1 != null
		&& !$p.__equals(nextPoint.controlPoint1,nextPoint)) {
		nextVec = nextPoint.controlPoint1;
		curveNormal2 = nextVec.sub( curVec).normalize();
		}

		 if (curPoint.controlPoint1 != null
		&& !$p.__equals(curPoint.controlPoint1,curPoint)
		&& prevVec != null) {
		prevVec = curPoint.controlPoint1;
		curveNormal1 = curVec.sub( prevVec).normalize();
		}

		if (curPoint.controlPoint2 != null
		&& !$p.__equals(curPoint.controlPoint2,curPoint)
		&& nextVec != null) {
		nextVec = curPoint.controlPoint2;
		curveNormal2 = nextVec.sub(curVec).normalize();
		}
		var newAnLeft1 = null,newAnRight1 =  null,newAnLeft2 =  null,newAnRight2 =  null;

		if((curveNormal1 != null && curveNormal1.x == 0 && curveNormal1.y ==0))
		curveNormal1 = curveNormalPrev1;

		if((curveNormal2 != null && curveNormal2.x == 0 && curveNormal2.y ==0))
		curveNormal2 = curveNormalPrev2;

		curveNormalPrev1 = curveNormal1;
		curveNormalPrev2 = curveNormal2;
		
		
		if (curveNormal1 != null) {
		newAnLeft1 =  curveNormal1
		.getRotated(Math.PI / 2);

		newAnLeft1.normalize();

		newAnLeft1.scaleSelf(tempOffset);
		newAnLeft1.addSelf(curVec);

		newAnRight1 =  curveNormal1
		.getRotated( (Math.PI / 2));
		newAnRight1.normalize();
		newAnRight1.scaleSelf(-tempOffset);
		newAnRight1.addSelf(curVec);
		}

		if (curveNormal2 != null ) {
		newAnLeft2 =  curveNormal2
		.getRotated( (Math.PI / 2));
		newAnLeft2.normalize();
		newAnLeft2.scaleSelf(tempOffset);
		newAnLeft2.addSelf(curVec);

		newAnRight2 =  curveNormal2
		.getRotated( (Math.PI / 2));
		newAnRight2.normalize();
		newAnRight2.scaleSelf(-tempOffset);
		newAnRight2.addSelf(curVec);
		}
		
		/*
		if (newAnLeft1 != null && newAnLeft2 != null
		&& $this_1.joinType == SketchSpline.JOIN_MITER) {
		var projectLen =  1000;
		var backLine =  newAnLeft1.add(curveNormal1.scale(projectLen));
		var fowardLine =  newAnLeft2.sub(curveNormal2
		.scale(projectLen));

		if (functions.intersect(newAnLeft1.x, newAnLeft1.y, backLine.x,
		backLine.y, newAnLeft2.x, newAnLeft2.y, fowardLine.x,
		fowardLine.y) == functions.DO_INTERSECT) {
		newAnLeft1.x = functions.x;
		newAnLeft1.y = functions.y;
		newAnLeft2.x = functions.x;
		newAnLeft2.y = functions.y;
		}
		}
	
		if (newAnRight1 != null && newAnRight2 != null
		&& $this_1.joinType == SketchSpline.JOIN_MITER) {
		var projectLen =  1000;
		var backLine =  newAnRight1
		.add(curveNormal1.scale(projectLen));
		var fowardLine =  newAnRight2.sub(curveNormal2
		.scale(projectLen));

		if (functions.intersect(newAnRight1.x, newAnRight1.y,
		backLine.x, backLine.y, newAnRight2.x, newAnRight2.y,
		fowardLine.x, fowardLine.y) == functions.DO_INTERSECT) {
		newAnRight1.x = functions.x;
		newAnRight1.y = functions.y;
		newAnRight2.x = functions.x;
		newAnRight2.y = functions.y;
		}
		}
		*/
		
		var outlinePointLeft1 =  null,outlinePointRight1 =  null,outlinePointLeft2 =  null,outlinePointRight2 =  null;
		
		if ($this_1.offsetType == SketchSpline.OFFSET_LEFT) {
		if (newAnLeft1 != null) {
		outlinePointLeft1 = new SketchPoint(newAnLeft1);
		outlinePointRight1 = new SketchPoint(curVec);
		}

		if (newAnLeft2 != null) {
		outlinePointLeft2 = new SketchPoint(newAnLeft2);
		outlinePointRight2 = new SketchPoint(curVec);
		}
		}

		if ($this_1.offsetType == SketchSpline.OFFSET_RIGHT) {
		if (newAnRight1 != null) {
		outlinePointLeft1 = new SketchPoint(curVec);
		outlinePointRight1 = new SketchPoint(newAnRight1);
		}

		if (newAnRight2 != null) {
		outlinePointLeft2 = new SketchPoint(curVec);
		outlinePointRight2 = new SketchPoint(newAnRight2);
		}
		}

		if ($this_1.offsetType == SketchSpline.OFFSET_BOTH) {
		if (newAnLeft1 != null && newAnRight1 != null) {
		outlinePointLeft1 = new SketchPoint(newAnLeft1);
		outlinePointRight1 = new SketchPoint(newAnRight1);
		
		}

		if (newAnLeft2 != null && newAnRight2 != null) {
		outlinePointLeft2 = new SketchPoint(newAnLeft2);
		outlinePointRight2 = new SketchPoint(newAnRight2);
		}
		}
		
		
		if ($this_1.joinType == SketchSpline.JOIN_ROUND) {
		if (outlinePointLeft1 != null && outlinePointLeft2 != null
		&& outlinePointLeft1.distanceTo(outlinePointLeft2) == 0) {
		var pushDist =  outlinePointRight1
		.distanceTo(outlinePointRight2) / 2;

		if (prevVec != null
		&& curVec.distanceTo(prevVec) < pushDist)
		pushDist = curVec.distanceTo(prevVec);

		if (nextVec != null
		&& curVec.distanceTo(nextVec) < pushDist)
		pushDist = curVec.distanceTo(nextVec);

		outlinePointLeft1.subSelf(curveNormal1.scale(pushDist));
		outlinePointLeft2.addSelf(curveNormal2.scale(pushDist));
		}

		if (outlinePointRight1 != null
		&& outlinePointRight2 != null
		&& outlinePointRight1.distanceTo(outlinePointRight2) == 0) {
		var pushDist =  outlinePointLeft1
		.distanceTo(outlinePointLeft2) / 2;

		if (prevVec != null
		&& curVec.distanceTo(prevVec) < pushDist)
		pushDist = curVec.distanceTo(prevVec);

		if (nextVec != null
		&& curVec.distanceTo(nextVec) < pushDist)
		pushDist = curVec.distanceTo(nextVec);

		outlinePointRight1.subSelf(curveNormal1.scale(pushDist));
		outlinePointRight2.addSelf(curveNormal2.scale(pushDist));
		}

		
		if (outlinePointLeft1 != null && outlinePointLeft2 != null
		&& outlinePointLeft1.distanceTo(outlinePointLeft2) > 0) {
		outlinePointLeft1.controlPoint1 = outlinePointLeft1
		.add(curveNormal1.scale(outlinePointLeft1
		.distanceTo(outlinePointLeft2) / 2));
		outlinePointLeft2.controlPoint2 = outlinePointLeft2
		.sub(curveNormal2.scale(outlinePointLeft1
		.distanceTo(outlinePointLeft2) / 2));
		}

		if (outlinePointRight1 != null
		&& outlinePointRight2 != null) {

			
		outlinePointRight1.controlPoint2 = outlinePointRight1
		.add(curveNormal1.scale(outlinePointRight1
		.distanceTo(outlinePointRight2) / 2));
		outlinePointRight2.controlPoint1 = outlinePointRight2
		.sub(curveNormal2.scale(outlinePointRight1
		.distanceTo(outlinePointRight2) / 2));
		}
		}

		if (outlinePointLeft1 != null)
		$this_1.outineLeft.add(outlinePointLeft1);

		if (outlinePointRight1 != null)
		$this_1.outineRight.add(outlinePointRight1);

		if (outlinePointLeft2 != null)
		$this_1.outineLeft.add(outlinePointLeft2);

		if (outlinePointRight2 != null)
		$this_1.outineRight.add(outlinePointRight2);
		
		}


		var leftOffset =  0;
		var rightOffset =  0;
		//$this_1.$self.getCentrePath().cacheLength(true);

		var loop =  1;

		if($this_1.$self.getCentrePath().getClosed())
		loop = 0;

		for (var i =  0;  i < $this_1.$self.getCentrePath().size() - loop;  i++) {
			
			var curPoint =  $this_1.$self.getCentrePath().get(i);
		
		var nextIndex =  i+1;

		if(i == $this_1.$self.getCentrePath().size()-1)
		nextIndex = 0;

		var nextPoint =  $this_1.$self.getCentrePath().get(nextIndex);
		

		tempOffset = $this_1.$self.getOffsetSize();
		tempOffsetNext = $this_1.$self.getOffsetSize();

		if ($this_1.$self.getCentreOffset().containsKey(i))
		tempOffset = $this_1.$self.getCentreOffset().get(i);

		if (nextPoint != null && $this_1.$self.getCentreOffset().containsKey(nextIndex)) {
		tempOffsetNext = $this_1.$self.getCentreOffset().get(nextIndex);
		}

		leftOffset++;
		rightOffset++;

		if ((curPoint.containsBezier() || nextPoint.containsBezier())) {
		var step =  $this_1.$self.getParentSketch().getSketchGlobals().BEZIER_DETAIL_OFFSET;

		var pDelta =  ($this_1.$self.getCentrePath().getPercent(nextPoint) - step)
		- ($this_1.$self.getCentrePath().getPercent(curPoint) + step);
		var p =  0;
		for (var s =  $this_1.$self.getCentrePath().getPercent(curPoint) + step;  s < $this_1.$self.getCentrePath()
		.getPercent(nextPoint) - step;  s += step) {
		var curveVec =  $this_1.$self.getCentrePath().getPos(s);
		var perp =  $this_1.$self.getCentrePath().getPerpendicular(s);

		var offset =  tempOffset;
		p += (step / pDelta);

		offset = (tempOffset * (1 - p)) + (tempOffsetNext * p);

		if(rightOffset < $this_1.outineRight.size()){
		$this_1.outineRight.add(
		rightOffset,
		new SketchPoint(curveVec.add(perp
		.getRotated( (Math.PI / 2))
		.normalize().scaleSelf(-offset))));
		rightOffset++;
		}
		if(leftOffset < $this_1.outineLeft.size()){
		$this_1.outineLeft.add(
		leftOffset,
		new SketchPoint(curveVec.add(perp
		.getRotated( (Math.PI / 2))
		.normalize().scaleSelf(offset))));
		leftOffset++;
		}
		}
		}

		leftOffset++;
		rightOffset++;
		}
	
//		$this_1.$self.getCentrePath().cacheLength(false);
		$this_1.$self.applyOutlineOffset();
		$this_1.$self.buildPath();

		return;
		
		if ($this_1.$self.getCap() == SketchSpline.CAP_LEG && $this_1.outineLeft.size() >= 2) {
		var start =  $this_1.$self.getCentrePath().get(0);
		var startNext =  $this_1.$self.getCentrePath().get(1);

		var startLeft =  $this_1.outineLeft.get(0);
		var startRight =  $this_1.outineRight.get(0);
		var endPrev =  $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 2);
		var end =  $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 1);
		var endLeft =  $this_1.outineLeft
		.get($this_1.outineLeft.size() - 1);
		var endRight =  $this_1.outineRight
		.get($this_1.outineRight.size() - 1);

		var a =   functions.angleOf(endLeft.sub(endRight)
		.normalize());
		a =  (a - Math.PI);
		var Adjacent =  end.distanceTo(endLeft);
		var Opposite =   (Math.tan(a) * Adjacent);
		var Hypotenues =   Math.sqrt(Math.pow(Adjacent, 2)
		+ Math.pow(Opposite, 2));

		if (Hypotenues > end.distanceTo(endPrev))
		Hypotenues = end.distanceTo(endPrev);

		var flip =  1;

		 if (a > (Math.PI / 2) || a < -(Math.PI / 2))
		flip = -flip;

		endLeft.y = end.y;
		endLeft.x = end.x + (Hypotenues * (-flip));
		endRight.y = end.y;
		endRight.x = end.x + (Hypotenues * flip);

		var startLen =  startLeft.distanceTo(startRight) / 2;
		var endLen =  endLeft.distanceTo(endRight) / 2;
		 var totalLen =  $this_1.$self.getlength();
		var arrayOffset =  1;

		var dir =  startLeft.sub(startRight).rotate( (Math.PI / 2));
		dir.normalize();

		var bezierLeftStart =  $this_1.outineLeft.get(0).copy();
		bezierLeftStart.addSelf(dir.scale(startLen * 1.5));

		var bezierRightStart =  $this_1.outineRight.get(0).copy();
		bezierRightStart.addSelf(dir.scale(startLen * 1.5));

		$this_1.path.addBezier(
		startLeft,startLeft.copy(), bezierLeftStart
		.copy());
		$this_1.path.addBezier(startRight, 
		bezierRightStart.copy(), startRight.copy());
		}

		if ($this_1.$self.getCap() == SketchSpline.CAP_PARRALEL && $this_1.outineLeft.size() >= 2) {
		var start =  $this_1.$self.getCentrePath().get(0);
		var startNext =  $this_1.$self.getCentrePath().get(1);

		var startLeft =  $this_1.outineLeft.get(0);
		var startRight =  $this_1.outineRight.get(0);
		var endPrev =  $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 2);
		var end =  $this_1.$self.getCentrePath().get(
		$this_1.$self.getCentrePath().size() - 1);
		var endLeft =  $this_1.outineLeft
		.get($this_1.outineLeft.size() - 1);
		var endRight =  $this_1.outineRight
		.get($this_1.outineRight.size() - 1);

		var a =   functions.angleOf(endLeft.sub(endRight)
		.normalize());
		a =  (a - Math.PI);
		var Adjacent =  end.distanceTo(endLeft);
		var Opposite =   (Math.tan(a) * Adjacent);
		var Hypotenues =   Math.sqrt(Math.pow(Adjacent, 2)
		+ Math.pow(Opposite, 2));

		if (Hypotenues > end.distanceTo(endPrev))
		Hypotenues = end.distanceTo(endPrev);

		var flip =  1;

		 if (a > (Math.PI / 2) || a < -(Math.PI / 2))
		flip = -flip;

		endLeft.y = end.y;
		endLeft.x = end.x + (Hypotenues * (-flip));
		endRight.y = end.y;
		endRight.x = end.x + (Hypotenues * flip);

		a =  functions
		.angleOf(startLeft.sub(startRight).normalize());
		a =  (a - Math.PI);
		Adjacent = start.distanceTo(startLeft);
		Opposite =  (Math.tan(a) * Adjacent);
		Hypotenues =  Math.sqrt(Math.pow(Adjacent, 2)
		+ Math.pow(Opposite, 2));

		if (Hypotenues > start.distanceTo(startNext))
		Hypotenues = start.distanceTo(startNext);

		flip = 1;

		 if (a > (Math.PI / 2) || a < -(Math.PI / 2))
		flip = -flip;

		startLeft.y = start.y;
		startLeft.x = start.x + (Hypotenues * (-flip));
		startRight.y = start.y;
		startRight.x = start.x + (Hypotenues * flip);
		}

		if ($this_1.$self.getCap() == SketchSpline.CAP_ROUND && $this_1.outineLeft.size() >= 2) {
		var startLeft =  $this_1.outineLeft.get(0);
		var startRight =  $this_1.outineRight.get(0);
		var endLeft =  $this_1.outineLeft
		.get($this_1.outineLeft.size() - 1);
		var endRight =  $this_1.outineRight
		.get($this_1.outineRight.size() - 1);

		var startLen =  startLeft.distanceTo(startRight) / 2;
		var endLen =  endLeft.distanceTo(endRight) / 2;
		 var totalLen =  $this_1.$self.getlength();
		var arrayOffset =  1;

		var dir =  startLeft.sub(startRight).rotate( (Math.PI / 2));
		dir.normalize();

		var bezierLeftStart =  $this_1.outineLeft.get(0).copy();
		bezierLeftStart.addSelf(dir.scale(startLen * 1.5));

		var bezierRightStart =  $this_1.outineRight.get(0).copy();
		bezierRightStart.addSelf(dir.scale(startLen * 1.5));

		$this_1.path.addBezier(
		startLeft,
		startLeft.copy(), bezierLeftStart
		.copy());
		$this_1.path.addBezier(startRight, 
		bezierRightStart.copy(), startRight.copy());

		var dirEnd =  endLeft.sub(endRight).rotate( (Math.PI / 2));
		dirEnd.normalize();

		var bezierLeftEnd =  $this_1.outineLeft.get(
		$this_1.outineLeft.size() - 1).copy();
		bezierLeftEnd.subSelf(dirEnd.scale(endLen * 1.5));

		var bezierRightEnd =  $this_1.outineRight.get(
		$this_1.outineRight.size() - 1).copy();
		bezierRightEnd.subSelf(dirEnd.scale(endLen * 1.5));

		$this_1.path
		.addBezier(
		endLeft,bezierLeftEnd.copy(), endLeft
		.copy());
		$this_1.path.addBezier(endRight, 
		endRight.copy(), bezierRightEnd.copy());
		}

		if ($this_1.$self.getCap() == SketchSpline.CAP_BUTT) {
		$this_1.$self.applyOutlineOffset();
		$this_1.$self.buildPath();
		}

		$this_1.isBuilt = true;
		}
		$p.addMethod($this_1, 'offset', offset$0);
		function optimize$0() {
		if (!$this_1.autoSmooth || $this_1.$self.getType() == SketchSpline.OFFSET_SPLINE)
		return;

		if ($this_1.$self.getCentrePath().size() < 3)
		return;

		var lastStoredPoint =   $this_1.$self.getCentrePath().get(0);
		var optimizedArray =  new $p.ArrayList();
		optimizedArray.add(lastStoredPoint);

		var step =  SETTINGS_SKETCH.spline_point_every / $this_1.$self.getlength();
		for (var i =  step;  i < 1 ;  i += step) {
		optimizedArray.add(new SketchPoint($this_1.$self.getPos(i)));
		}
		optimizedArray.add($this_1.$self.getCentrePath().get($this_1.$self.getCentrePath().size() - 1));
		  $this_1.$self.getCentrePath().setPath( optimizedArray);

		for (var i =  0;  i < $this_1.$self.getSelectedNodes().size();  i++) {
		var selectedNode =   $this_1.$self.getSelectedNodes()
		.get(i);
		var index =  $this_1.$self.getNearestVecIndex(selectedNode);
		$this_1.$self.getCentrePath().set(index, selectedNode);
		}
		}
		$p.addMethod($this_1, 'optimize', optimize$0);
		function optimizeRange$2(startVec, endVec) {
		if (!$this_1.autoSmooth || $this_1.$self.getType() == SketchSpline.OFFSET_SPLINE)
		return;

		if ($this_1.$self.getCentrePath().size() < 3)
		return;

		 var startList =  new $p.ArrayList();
		var middleList =  new $p.ArrayList();
		var endList =  new $p.ArrayList();

		 var startIndex =  $this_1.$self.getIndex(startVec);
		var endIndex =  $this_1.$self.getIndex(endVec);

		 var beforeStart =  null;
		var afterEnd =  null;

		if (startIndex > 0)
		beforeStart =  $this_1.$self.getCentrePath().get(startIndex - 1);

		if (endIndex < $this_1.$self.getCentrePath().size() - 1)
		afterEnd =  $this_1.$self.getCentrePath().get(endIndex + 1);

		 for (var i =  0;  i < startIndex - 2;  i++) {
		var vec =   $this_1.$self.getCentrePath().get(i);
		startList.add(vec);
		}

		var step =  SETTINGS_SKETCH.spline_point_every / $this_1.$self.getlength();
		 var startPos =  $this_1.$self.getLenTo(beforeStart) / $this_1.$self.getlength();

		if (beforeStart == null)
		startPos = 0;

		var endPos =  $this_1.$self.getLenTo(afterEnd) / $this_1.$self.getlength();

		if (afterEnd == null)
		endPos = 1;

		for (var i =  startPos;  i < endPos;  i += step) {
		var addVec =  $this_1.$self.getPos(i);
		var addP =  new SketchPoint(addVec);

		if (i < 1 - step)
		;
		middleList.add(addP);
		}

		for (var i =  endIndex;  i < $this_1.$self.getCentrePath().size();  i++) {
		var vec =   $this_1.$self.getCentrePath().get(i);
		endList.add(vec);
		}

		for (var i =  0;  i < middleList.size();  i++) {
		var vec =  middleList.get(i);
		startList.add(vec);
		}

		for (var i =  0;  i < endList.size();  i++) {
		var vec =  endList.get(i);
		startList.add(vec);
		}

		$this_1.$self.getCentrePath().setPath(startList);

		for (var i =  0;  i < $this_1.$self.getSelectedNodes().size();  i++) {
		var selectedNode =   $this_1.$self.getSelectedNodes()
		.get(i);
		var index =  $this_1.$self.getNearestVecIndex(selectedNode);

		if (index != -1)
		$this_1.$self.getCentrePath().set(index, selectedNode);
		}
		}
		$p.addMethod($this_1, 'optimizeRange', optimizeRange$2);
		function removeVertex$1(v) {
		if ($p.__contains($this_1.$self.getCentrePath(),v)) {
		$this_1.$self.getCentrePath().remove(v);
		$this_1.$self.build();
		}

		if ($this_1.$self.getCentrePath().size() == 1)
		$this_1.$self.destroy();
		}
		$p.addMethod($this_1, 'removeVertex', removeVertex$1);
		function render$1(g) {
			

		var s =  $this_1.$self.getParentSketch();
		var st =  s.getSketchTools();

		$this_1.path.editable = false;
		$this_1.path.setParentSketch($this_1.$self.getParentSketch());
		$this_1.path.render(g);
		$this_1.centrePath.editable = true;
		$this_1.centrePath.setType($this_1.$self.getType());
		$this_1.centrePath.setClosed(false);
		$this_1.centrePath.render(g);
		}
		$p.addMethod($this_1, 'render', render$1);
		function renderNodes$1(g) {
		var selectDia =  SETTINGS_SKETCH.select_dia
		* (1 / $this_1.$self.getParentSketch().getZOOM());

		if (selectDia > SETTINGS_SKETCH.select_dia * 1.5)
		selectDia = SETTINGS_SKETCH.select_dia;

		selectDia = selectDia / 2;

		if (true) {
		g.noFill();
		g.stroke(SETTINGS_SKETCH.CONTROL_POINT_STROKE_COLOUR);
		g.fill(SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR);

		var startVect =   $this_1.$self.getCentrePath().get(0);
		if(startVect != null)
		g.ellipse(startVect.x, startVect.y, selectDia,selectDia);

		var endVect =   $this_1.$self.getCentrePath().get($this_1.$self.getCentrePath().size()-1);
		if(startVect != null)
		g.ellipse(endVect.x, endVect.y, selectDia,selectDia);

		g.noFill();
		g.beginShape();	
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);

		g.vertex(curVec.x,curVec.y);
		}
		g.endShape();

		g.noFill();
		}
		}
		$p.addMethod($this_1, 'renderNodes', renderNodes$1);
		function renderPickBuffer$1(g) {
		$this_1.path.renderPickBuffer(g);
		}
		$p.addMethod($this_1, 'renderPickBuffer', renderPickBuffer$1);
		function renderSilhouette$1(g) {
		$this_1.path.renderSilhouette(g);
		}
		$p.addMethod($this_1, 'renderSilhouette', renderSilhouette$1);
		function replace$1(clone) {
		var cloneLocal =   clone;

		$this_1.$self.getCentrePath().setPath(cloneLocal.getCentrePath().getList());
		$this_1.outineLeft = cloneLocal.outineLeft;
		$this_1.outineRight = cloneLocal.outineRight;
		$this_1.slots = cloneLocal.slots;

		$this_1.$self.setOffsetSize(cloneLocal.getOffsetSize());
		$this_1.path = cloneLocal.path;
		$this_1.path.editable = false;
		$this_1.isBuilt = cloneLocal.isBuilt;
		$this_1.offsetType = cloneLocal.offsetType;
		}
		$p.addMethod($this_1, 'replace', replace$1);
		function scale$2(scale, centre) {
		$this_1.$self.setOffsetSize($this_1.$self.getOffsetSize()
		+ ($this_1.$self.getOffsetSize() * scale));
		$this_1.$self.getCentrePath().scale(scale, centre);
		$this_1.path.scale(scale, centre);
		}
		$p.addMethod($this_1, 'scale', scale$2);
		function select$0() {
		$this_1.selected = true;
		if ($this_1.path != null)
		$this_1.path.select();

		$this_1.$self.getCentrePath().select();
		}
		$p.addMethod($this_1, 'select', select$0);
		function unselect$0() {
		$this_1.selected = false;

		if ($this_1.path != null)
		$this_1.path.unselect();

		$this_1.$self.getCentrePath().unselect();
		}
		$p.addMethod($this_1, 'unselect', unselect$0);
		function selectNodes$2(mouseX, mouseY) {
		var shapeSelected =  false;
		var selectDia =  SETTINGS_SKETCH.select_dia
		* (1 / $this_1.$self.getParentSketch().getZOOM());

		if (selectDia > SETTINGS_SKETCH.select_dia * 1.5)
		selectDia = SETTINGS_SKETCH.select_dia;

		$this_1.$self.unselectNodes();
		$this_1.path.unselectNodes();
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var v =   $this_1.$self.getCentrePath().get(i);
		if (v.distanceTo(new Vec2D(mouseX, mouseY)) < selectDia) {
		$this_1.$self.getSelectedNodes().add(v);
		shapeSelected = true;
		}
		}  
		if (shapeSelected && $this_1.$self.getParentSketch().getSketchGlobals().undo != null)
		$this_1.$self.getParentSketch().getSketchGlobals().undo
		.addOperation(new UndoAction($this_1.$self, $this_1.$self.clone(),
		UndoAction.EDIT_SHAPE));

		 $this_1.$self.getCentrePath().selectNodes(mouseX, mouseY);

		if ($this_1.path.getSelectedNodes().size() > 0 && !shapeSelected)
		$this_1.$self.getParentSketch().getSketchGlobals().undo
		.addOperation(new UndoAction($this_1.$self, $this_1.$self.clone(),
		UndoAction.EDIT_SHAPE));
		}
		$p.addMethod($this_1, 'selectNodes', selectNodes$2);
		function setCap$1(cap) {
		$this_1.capType = cap;
		}
		$p.addMethod($this_1, 'setCap', setCap$1);
		function setCentreOffset$1(centreOffset) {
		$this_1.centreOffset = centreOffset;
		}
		$p.addMethod($this_1, 'setCentreOffset', setCentreOffset$1);
		function setCentrePath$1(centrePath) {
		$this_1.centrePath = centrePath;
		}
		$p.addMethod($this_1, 'setCentrePath', setCentrePath$1);
		function setJoinType$1(j) {
		$this_1.joinType = j;
		}
		$p.addMethod($this_1, 'setJoinType', setJoinType$1);
		function setOffsetSize$1(offsetSize) {
		$this_1.offsetSize = offsetSize;
		}
		$p.addMethod($this_1, 'setOffsetSize', setOffsetSize$1);
		function setOffsetSizeCentre$1(val) {
		for (var i =  0;  i < $this_1.$self.getCentrePath().getSelectedNodes().size();  i++) {
		var p =   $this_1.$self.getCentrePath()
		.getSelectedNodes().get(i);
		var index =  $this_1.$self.getCentrePath().l.indexOf(p);
		$this_1.$self.getCentreOffset().put(index, val);
		}
		}
		$p.addMethod($this_1, 'setOffsetSizeCentre', setOffsetSizeCentre$1);
		function setVec2DpickBuffer$5(col, selectedVec, selectedShape, selectedVecPlane, isSelectedVecOnOutline) {
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);

		if (col == $this_1.$self.getColor(i + ($this_1.id * 100))) {
		isSelectedVecOnOutline = false;
		selectedShape = $this_1.$self;
		selectedVec = curVec;

		return selectedVec;
		}
		}

		for (var i =  0;  i < $this_1.$self.getCombinedSize();  i++) {
		var curVec =   $this_1.$self.getCombined(i);
		if (col == $this_1.$self.getColor($this_1.$self.getCentrePath().size() + i + ($this_1.id * 100))) {
		isSelectedVecOnOutline = true;
		selectedShape = $this_1.$self;
		selectedVec = curVec;
		return selectedVec;
		}
		}
		selectedVec = null;
		return null;
		}
		$p.addMethod($this_1, 'setVec2DpickBuffer', setVec2DpickBuffer$5);
		function toXML$0() {
		var element =  new Element("SketchSpline");

		element.addAttribute(new Attribute("id", String.valueOf($this_1.$self.getId())));
		element.addAttribute(new Attribute("outlineId", String
		.valueOf($this_1.path.getId())));
		element.addAttribute(new Attribute("centreId", String.valueOf($this_1.$self
		.getCentrePath().getId())));

		element.addAttribute(new Attribute("offsetSize", String.valueOf($this_1.$self
		.getOffsetSize())));

		element.addAttribute(new Attribute("splineType", String.valueOf($this_1.$self
		.getType())));

		element.addAttribute(new Attribute("endCap", String.valueOf($this_1.$self
		.getCap())));

		element.addAttribute(new Attribute("joinType", String.valueOf($this_1.$self
		.getJoinType())));

		if ($this_1.isConstructionLine())
		element.addAttribute(new Attribute("isConstructionLine", "true"));

		element.addAttribute(new Attribute("union", String.valueOf($this_1.union)));

		var elementCentre =  new Element("SketchSplineCentrePath");
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var point =  $this_1.$self.getCentrePath().get(i);
		elementCentre.appendChild(point.toXML());
		}

		element.appendChild(elementCentre);

		var SketchSplineOffsets =  new Element("SketchSplineOffsets");
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);

		if ($this_1.outlineOffset.containsKey(i)) {
		var offset =  $this_1.outlineOffset.get(i);
		var SketchSplineOffset =  new Element("SketchSplineOffset");
		SketchSplineOffset.addAttribute(new Attribute("linked_id",
		String.valueOf(i)));
		SketchSplineOffset.addAttribute(new Attribute("x_offset",
		String.valueOf(offset.x)));
		SketchSplineOffset.addAttribute(new Attribute("y_offset",
		String.valueOf(offset.y)));

		SketchSplineOffsets.appendChild(SketchSplineOffset);
		}
		}

		var SketchSplinePathOffsets =  new Element("SketchSplinePathOffsets");
		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);

		if ($this_1.$self.getCentreOffset().containsKey(i)) {
		var offset =  $this_1.$self.getCentreOffset().get(i);
		var SketchSplineOffset =  new Element(
		"SketchSplinePathOffset");
		SketchSplineOffset.addAttribute(new Attribute("linked_index",
		String.valueOf(i)));
		SketchSplineOffset.addAttribute(new Attribute("offset", String
		.valueOf(offset)));

		SketchSplinePathOffsets.appendChild(SketchSplineOffset);
		}
		}

		element.appendChild(SketchSplinePathOffsets);

		for (var i =  0;  i < $this_1.$self.getCentrePath().size();  i++) {
		var curVec =   $this_1.$self.getCentrePath().get(i);
		var i2 =  (($this_1.$self.getCentrePath().size() * 2) - i - 1);

		if ($this_1.outlineOffset.containsKey(i2)) {
		var offset =  $this_1.outlineOffset.get(i2);

		var SketchSplineOffset =  new Element("SketchSplineOffset");

		SketchSplineOffset.addAttribute(new Attribute("linked_id",
		String.valueOf(i2)));
		SketchSplineOffset.addAttribute(new Attribute("x_offset",
		String.valueOf(offset.x)));
		SketchSplineOffset.addAttribute(new Attribute("y_offset",
		String.valueOf(offset.y)));

		SketchSplineOffsets.appendChild(SketchSplineOffset);
		}
		}

		element.appendChild(SketchSplineOffsets);

		return element;
		}
		$p.addMethod($this_1, 'toXML', toXML$0);
		function $constr_1(parentSketch){
		$superCstr(parentSketch);

		$this_1.path = new SketchPath($this_1.$self.getParentSketch());
		$this_1.centrePath = new SketchPath($this_1.$self.getParentSketch());
		$this_1.id = $this_1.$self.getParentSketch().sketch_id++;
		$this_1.$self.setType(SketchShape.TYPE_SPLINE);
		$this_1.path.editable = false;
		$this_1.path.setClosed(true);
		$this_1.path.setParentSketch($this_1.$self.getParentSketch());
		}

		function $constr_2(parentSketch, element){
		$superCstr(parentSketch);
		$this_1.$self.setParentSketch(parentSketch);
		$this_1.path = new SketchPath($this_1.$self.getParentSketch());
		$this_1.centrePath = new SketchPath($this_1.$self.getParentSketch());

		 if (!$p.__equals(element.getLocalName(),"SketchSpline"))
		return;

		if (element.getAttributeValue("id") != null) {
		$this_1.$self.setId(Integer.valueOf(element.getAttributeValue("id")));
		}

		if (element.getAttributeValue("outlineId") != null) {
		$this_1.path.setId(Integer.valueOf(element
		.getAttributeValue("outlineId")));
		}

		if (element.getAttributeValue("centreId") != null) {
		$this_1.$self.getCentrePath().setId(
		Integer.valueOf(element.getAttributeValue("centreId")));
		}

		if (element.getAttributeValue("offsetSize") != null) {
		$this_1.$self.setOffsetSize(Float.valueOf(element
		.getAttributeValue("offsetSize")));
		}

		if (element.getAttributeValue("splineType") != null) {
		$this_1.$self.setType(Integer.valueOf(element
		.getAttributeValue("splineType")));
		}

		if (element.getAttributeValue("endCap") != null) {
		$this_1.$self.setCap(Integer.valueOf(element.getAttributeValue("endCap")));
		}

		if (element.getAttributeValue("joinType") != null) {
		$this_1.$self.setJoinType(Integer.valueOf(element
		.getAttributeValue("joinType")));
		}

		 if ($this_1.$self.getType() == 0) {
		if (element.getAttributeValue("offsetSizeEnd") != null) {
		$this_1.$self.getCentreOffset().put(1,
		Float.valueOf(element.getAttributeValue("offsetSizeEnd")));
		}

		$this_1.capType = SketchSpline.CAP_LEG;
		$this_1.$self.setType(SketchSpline.TYPE_LEG);
		}

		if (element.getAttributeValue("isConstructionLine") != null) {
		$this_1.$self.setIsContructionLine(true);
		}

		if (element.getAttributeValue("union") != null) {
		$this_1.union = Integer.valueOf(element.getAttributeValue("union"));
		}

		 for (var i =  0;  i < element.getChildCount();  i++) {
		var child =   element.getChild(i);

		if (child != null && $p.__equals(child.getLocalName(),"SketchPoint"))
		$this_1.$self.getCentrePath().add(new SketchPoint(child));

		if (child != null
		&& $p.__equals(child.getLocalName(),"SketchSplineCentrePath")) {
		for (var j =  0;  j < child.getChildCount();  j++) {
		var child2 =   child.getChild(j);

		if (child2 != null
		&& $p.__equals(child2.getLocalName(),"SketchPoint"))
		$this_1.$self.getCentrePath().add(new SketchPoint(child2));
		}
		}

		if (child != null
		&& $p.__equals(child.getLocalName(),"SketchSplineOffsets")) {
		for (var j =  0;  j < child.getChildCount();  j++) {
		var child2 =   child.getChild(j);
		if (child2 != null
		&& $p.__equals(child2.getLocalName(),"SketchSplineOffset")) {
		if (child2.getAttributeValue("linked_id") != null
		&& child2.getAttributeValue("x_offset") != null
		&& child2.getAttributeValue("y_offset") != null) {
		var index =  Integer.valueOf(child2
		.getAttributeValue("linked_id"));
		var x_offset =  Float.valueOf(child2
		.getAttributeValue("x_offset"));
		var y_offset =  Float.valueOf(child2
		.getAttributeValue("y_offset"));

		$this_1.outlineOffset.put(index, new SketchPoint(x_offset,
		y_offset));
		}
		}
		}
		}

		if (child != null
		&& $p.__equals(child.getLocalName(),"SketchSplinePathOffsets")) {
		for (var j =  0;  j < child.getChildCount();  j++) {
		var child2 =   child.getChild(j);
		if (child2 != null
		&& $p.__equals(child2.getLocalName(),"SketchSplinePathOffset")) {
		if (child2.getAttributeValue("linked_index") != null
		&& child2.getAttributeValue("offset") != null) {
		var index =  Integer.valueOf(child2
		.getAttributeValue("linked_index"));
		var offset =  Float.valueOf(child2
		.getAttributeValue("offset"));

		$this_1.$self.getCentreOffset().put(index, offset);
		}
		}
		}
		}
		}
		$this_1.$self.setClosed(true);

		$this_1.path.editable = false;
		$this_1.path.setClosed(true);
		}

		function $constr_2(parentSketch, offsetType){
		$superCstr(parentSketch);
		$this_1.$self.setParentSketch(parentSketch);

		$this_1.path = new SketchPath($this_1.$self.getParentSketch());
		$this_1.centrePath = new SketchPath($this_1.$self.getParentSketch());
		$this_1.offsetType = offsetType;
		$this_1.id = $this_1.$self.getParentSketch().sketch_id++;
		$this_1.path.editable = false;
		$this_1.path.setClosed(true);
		$this_1.path.setParentSketch($this_1.$self.getParentSketch());
		}

		function $constr() {
		if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		$p.extendStaticMembers(SketchSpline, SketchShape);
		SketchSpline.TYPE_LEG =  43;
		SketchSpline.CAP_ROUND =  1;
		SketchSpline.CAP_BUTT =  2;
		SketchSpline.CAP_SQUARE =  3;
		SketchSpline.CAP_PARRALEL =  4;
		SketchSpline.CAP_LEG =  5;
		SketchSpline.JOIN_BEVEL =  1;
		SketchSpline.JOIN_MITER =  2;
		SketchSpline.JOIN_ROUND =  3;
		SketchSpline.OFFSET_LEFT =  0;
		SketchSpline.OFFSET_RIGHT =  1;
		SketchSpline.OFFSET_BOTH =  2;
		SketchSpline.$base = SketchShape;
		return SketchSpline;
		})();
		$p.SketchSpline = SketchSpline;
		var SketchPath = (function() {
		function SketchPath() {
		var $this_1 = this;
		var $super = { $upcast: $this_1 };
		function $superCstr(){SketchShape.apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}
		$this_1.l =  new $p.ArrayList();
		$this_1.isOptimized = false;
		$this_1.pointDist =  5;
		$this_1.offsetSize =  20;
		$this_1.slots =  new SliceSlots();
		$this_1.slots_on_inside =  true;
		$this_1.offsetType =  2;
		$this_1.isOutline = false;
		$this_1.cacheLength =  false;
		$this_1.cachedLength =  -1;
		$this_1.lastStepPercent = 0;
		$this_1.lastStepStartPos = 0;
		$this_1.lastStepLengthAlong = 0;
		$this_1.lastStepAlongBezier = 0;
		$this_1.lastStepMeasuredPoint = null;
		$this_1.lastStepLenghtSegment = 0;
		$this_1.woundClockwise = false;
		$this_1.woundClockwiseReset = false;
		$this_1.cachedGetMaxX = 0;
		$this_1.cachedGetMaxY = 0;
		$this_1.cachedGetMinX = 0;
		$this_1.cachedGetMinY = 0;
		$p.defineProperty($this_1, 'OFFSET_LEFT', {get: function(){return SketchPath.OFFSET_LEFT}, set: function(val){SketchPath.OFFSET_LEFT = val}});
		$p.defineProperty($this_1, 'OFFSET_RIGHT', {get: function(){return SketchPath.OFFSET_RIGHT}, set: function(val){SketchPath.OFFSET_RIGHT = val}});
		$p.defineProperty($this_1, 'OFFSET_BOTH', {get: function(){return SketchPath.OFFSET_BOTH}, set: function(val){SketchPath.OFFSET_BOTH = val}});
		function add$2(i, point) {
		$this_1.l.add(i, point);
		$this_1.$self.resetCachedVariables();
		}
		$p.addMethod($this_1, 'add', add$2);
		function add$1_2(point) {
		$this_1.l.add(point);
		$this_1.$self.resetCachedVariables();
		}
		$p.addMethod($this_1, 'add', add$1_2);
		function addBezier$3(point, controlP1, controlP2) {
		point.controlPoint1 = controlP1;
		point.controlPoint2 = controlP2;
		}
		$p.addMethod($this_1, 'addBezier', addBezier$3);
		function build$0() {
		$this_1.$self.woudClockwiseReset();
		}
		$p.addMethod($this_1, 'build', build$0);
		function cacheLength$1(cache) {
		$this_1.cacheLength = cache;
		$this_1.cachedLength = -1;
		}
		$p.addMethod($this_1, 'cacheLength', cacheLength$1);
		function clone$0() {
		var newSpline =  new SketchPath($this_1.$self.getParentSketch());

		newSpline.setClosed($this_1.$self.getClosed());
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curPoint =  $this_1.l.get(i);
		var point =  curPoint.clone(); newSpline.l.add(point);
		}

		newSpline.slots = $this_1.slots.clone();

		return newSpline;
		}
		$p.addMethod($this_1, 'clone', clone$0);
		function cloneArray$0() {
		var loop =  new $p.ArrayList();
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i).clone();
		loop.add(v);
		}  return loop;
		}
		$p.addMethod($this_1, 'cloneArray', cloneArray$0);
		function contains$1(vec) {
		return $p.__contains($this_1.l,vec);
		}
		$p.addMethod($this_1, 'contains', contains$1);
		function copy$1(parentSketch) {
		var newSpline =  new SketchPath(parentSketch);

		newSpline.setClosed($this_1.$self.getClosed());
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curPoint =  $this_1.l.get(i);
		var point =  curPoint.clone(); newSpline.l.add(point);
		}

		newSpline.slots = $this_1.slots.clone();
		newSpline.setId($this_1.$self.getId());
		return newSpline;
		}
		$p.addMethod($this_1, 'copy', copy$1);
		function destroy$0() {
		$this_1.$self.setDestroy(true);
		}
		$p.addMethod($this_1, 'destroy', destroy$0);
		function flipHorizontal$1(centre) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);
		curVec.x -= (curVec.x - centre.x) * 2;

		if (curVec.containsBezier()) {
		if (curVec.controlPoint1 != null) {
		curVec.controlPoint1.x -= (curVec.controlPoint1.x - centre.x) * 2;
		}

		if (curVec.controlPoint2 != null) {
		curVec.controlPoint2.x -= (curVec.controlPoint2.x - centre.x) * 2;
		}
		}
		}
		}
		$p.addMethod($this_1, 'flipHorizontal', flipHorizontal$1);
		function get$1(i) {
		return $this_1.l.get(i);
		}
		$p.addMethod($this_1, 'get', get$1);
		function getCentreOfMass$0() {
		var x =  0;
		var y =  0;

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);

		x += v.x;
		y += v.y;
		}
		return new SketchPoint(x / $this_1.l.size(), y / $this_1.l.size());
		}
		$p.addMethod($this_1, 'getCentreOfMass', getCentreOfMass$0);
		function getCentre$0() {
		return new SketchPoint($this_1.$self.getMinX() + ($this_1.$self.getWidth() / 2),
		$this_1.$self.getMinY() + ($this_1.$self.getHeight() / 2));
		}
		$p.addMethod($this_1, 'getCentre', getCentre$0);
		function getWidth$0() {
		return $this_1.$self.getMaxX() - $this_1.$self.getMinX();
		}
		$p.addMethod($this_1, 'getWidth', getWidth$0);
		function getHeight$0() {
		return $this_1.$self.getMaxY() - $this_1.$self.getMinY();
		}
		$p.addMethod($this_1, 'getHeight', getHeight$0);
		function getClosestPercent$2(mouseX, mouseY) {
		var closestDist =  -1;
		var val =  -1;
		$this_1.$self.cacheLength(true);
		var mousePos =  new SketchPoint(mouseX, mouseY);
		var step =  SETTINGS_SKETCH.select_on_path_step / $this_1.$self.getlength();
		for (var i =  0;  i <= 1;  i += step) {
		var pos =  $this_1.$self.getPos(i);

		if (i == 0 || pos.distanceTo(mousePos) < closestDist && pos != null) {
		val = i;
		closestDist = pos.distanceTo(mousePos);
		}
		}
		$this_1.$self.cacheLength(false);

		return val;
		}
		$p.addMethod($this_1, 'getClosestPercent', getClosestPercent$2);
		function getClosestPoint$1(pointOnPlan) {
		return null;
		}
		$p.addMethod($this_1, 'getClosestPoint', getClosestPoint$1);
		function getClosestPoint$1_2(pointOnPlan) {
		var p =  null;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);

		if (p == null
		|| curVec.distanceTo(pointOnPlan) < p
		.distanceTo(pointOnPlan))
		p = curVec;
		}

		return p;
		}
		$p.addMethod($this_1, 'getClosestPoint', getClosestPoint$1_2);
		function getClosestPointAlongPath$2(x, y) {
		var closestDist =  -1;
		var closestPoint =  null;
		$this_1.$self.cacheLength(true);
		$this_1.$self.resetPosStep();
		var mousePos =  new SketchPoint(x, y);
		var step =  SETTINGS_SKETCH.select_on_path_step / $this_1.$self.getlength();
		step = .1;
		for (var i =  0;  i < 1;  i += step) {
		var pos =  $this_1.$self.getPosStep(step);
		if ((closestDist == -1 && pos != null)
		|| (pos != null && pos.distanceTo(mousePos) < closestDist)) {
		closestPoint = pos;
		closestDist = pos.distanceTo(mousePos);
		}
		}
		$this_1.$self.cacheLength(false);

		return closestPoint;
		}
		$p.addMethod($this_1, 'getClosestPointAlongPath', getClosestPointAlongPath$2);
		function getClosestPointOnLine$2(mouseX, mouseY) {
		var closestDist =  -1;
		var val =  -1;
		var v =  null;

		var mousePos =  new SketchPoint(mouseX, mouseY);
		var step =  SETTINGS_SKETCH.select_on_path_step / $this_1.$self.getlength();
		for (var i =  0;  i < 1;  i += step) {
		var pos =  $this_1.$self.getPos(i);

		if (closestDist == -1 || pos.distanceTo(mousePos) < closestDist) {
		val = i;
		closestDist = pos.distanceTo(mousePos);
		v = pos;
		}
		}

		return v;
		}
		$p.addMethod($this_1, 'getClosestPointOnLine', getClosestPointOnLine$2);
		function getColor$1(id) {
		return -(id + 2);
		}
		$p.addMethod($this_1, 'getColor', getColor$1);
		function getIndex$1(p) {
		return $this_1.l.indexOf(p);
		}
		$p.addMethod($this_1, 'getIndex', getIndex$1);
		function getLast$0() {
		if ($this_1.l.size() > 0)
		return $this_1.l.get($this_1.l.size() - 1);
		else
		return null;
		}
		$p.addMethod($this_1, 'getLast', getLast$0);
		function getlength$0() {
		if ($this_1.cachedLength != -1 && $this_1.cacheLength)
		return $this_1.cachedLength;

		var length =  0;

		var offset =  0;

		if (!$this_1.$self.getClosed())
		offset = 1;

		$this_1.cachedLength = $this_1.$self.getLengthTo($this_1.l.size() - offset);
		return $this_1.cachedLength;
		}
		$p.addMethod($this_1, 'getlength', getlength$0);
		function getLength$0() {
		return $this_1.l.size();
		}
		$p.addMethod($this_1, 'getLength', getLength$0);
		function getLengthBetween$2(indexStart, indexEnd) {
		var length =  0;

		var lastMeasured =  null;
		for (var i =  indexStart;  i < indexEnd;  i++) {
		var curVec =  $this_1.l.get(i);
		var nextVec =  null;
		if (i < $this_1.l.size() - 1)
		nextVec = $this_1.l.get(i + 1);
		else
		nextVec = $this_1.l.get(0);

		if (curVec.containsBezier() || nextVec.containsBezier()) {
		var bez1 =  curVec;
		var bez2 =  nextVec;

		if (curVec.containsBezier()) {
		bez1 = curVec.getControlPoint2();
		}

		if (nextVec.containsBezier()) {
		bez2 = nextVec.getControlPoint1();
		}

		lastMeasured = curVec.copy();
		var step =  $this_1.$self.getParentSketch().getSketchGlobals().BEZIER_DETAIL_CALCULATIONS;
		;
		for (var t =  0;  t <= 1;  t += step) {
		var x =  functions.bezierPoint(curVec.x, bez1.x, bez2.x,
		nextVec.x, t);
		var y =  functions.bezierPoint(curVec.y, bez1.y, bez2.y,
		nextVec.y, t);
		length += lastMeasured.distanceTo(new Vec2D(x, y));
		lastMeasured = new Vec2D(x, y);
		}
		} else {
		length += curVec.distanceTo(nextVec);
		lastMeasured = nextVec.copy();
		}
		}

		return length;
		}
		$p.addMethod($this_1, 'getLengthBetween', getLengthBetween$2);
		function getlengthPerPercent$0() {
		return $this_1.$self.getlength() / 100;
		}
		$p.addMethod($this_1, 'getlengthPerPercent', getlengthPerPercent$0);
		function getLengthTo$1(index) {
		return $this_1.$self.getLengthBetween(0, index);
		}
		$p.addMethod($this_1, 'getLengthTo', getLengthTo$1);
		function getList$0() {
		return  $this_1.l;
		}
		$p.addMethod($this_1, 'getList', getList$0);
		function getMaxX$0() {
		if ($this_1.cachedGetMaxX != -1)
		return $this_1.cachedGetMaxX;

		var maxX =  0;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);
		if (i == 0 || v.x > maxX)
		maxX = v.x;
		}
		$this_1.cachedGetMaxX = maxX;
		return maxX;
		}
		$p.addMethod($this_1, 'getMaxX', getMaxX$0);
		function getMaxY$0() {
		if ($this_1.cachedGetMaxY != -1)
		return $this_1.cachedGetMaxY;

		var maxY =  0;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);
		if (i == 0 || v.y > maxY)
		maxY = v.y;
		}
		$this_1.cachedGetMaxY = maxY;
		return maxY;
		}
		$p.addMethod($this_1, 'getMaxY', getMaxY$0);
		function getMinX$0() {
		if ($this_1.cachedGetMinX != -1)
		return $this_1.cachedGetMinX;

		var minX =  0;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);
		if (i == 0 || v.x < minX)
		minX = v.x;
		}
		$this_1.cachedGetMinX = minX;
		return minX;
		}
		$p.addMethod($this_1, 'getMinX', getMinX$0);
		function getMinY$0() {
		if ($this_1.cachedGetMinY != -1)
		return $this_1.cachedGetMinY;

		var minY =  0;
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);
		if (i == 0 || v.y < minY)
		minY = v.y;
		}
		$this_1.cachedGetMinY = minY;
		return minY;
		}
		$p.addMethod($this_1, 'getMinY', getMinY$0);
		function getNodeBetween$2(t1, t2) {
		if (t1 > 1 || t1 < 0 || t2 > 1 || t2 < 0)
		return null;

		var totalLen =  $this_1.$self.getlength();
		var destLen1 =  totalLen * t1;
		var destLen2 =  totalLen * t2;
		var length =  0;

		for (var i =  0;  i < $this_1.l.size() - 1;  i++) {
		var curVec =  $this_1.l.get(i);
		var nextVec =  $this_1.l.get(i + 1);
		length += curVec.distanceTo(nextVec);

		if (length > destLen1) {
		if (length < destLen2)
		return nextVec;
		else
		return null;
		}
		}

		return null;
		}
		$p.addMethod($this_1, 'getNodeBetween', getNodeBetween$2);
		function getOutlineGeneralPath$0() {
		var gPath =  new GeneralPath();

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  null;
		var nextVec =  null;

		if (i >= $this_1.l.size() - 1) {
		nextVec = $this_1.l.get(0);
		} else {
		nextVec = $this_1.l.get(i + 1);
		}

		curVec = $this_1.l.get(i);

		if (i == 0) {
		gPath.moveTo(curVec.x, curVec.y);
		}
		if (i == $this_1.l.size() - 1) {
		gPath.moveTo(curVec.x, curVec.y);
		}

		if (curVec.containsBezier() || nextVec.containsBezier()) {
		gPath.curveTo(curVec.getControlPoint2().x,
		curVec.getControlPoint2().y,
		nextVec.getControlPoint1().x,
		nextVec.getControlPoint1().y, nextVec.x, nextVec.y);
		} else {
		gPath.lineTo(nextVec.x, nextVec.y);
		}
		}

		return gPath;
		}
		$p.addMethod($this_1, 'getOutlineGeneralPath', getOutlineGeneralPath$0);
		function getOverShape$2(x, y) {
		var closePoint =  $this_1.$self.getClosestPointAlongPath(x, y);
		if (closePoint != null
		&& closePoint.distanceTo(new Vec2D(x, y)) < SETTINGS_SKETCH.SELECT_EDGE_DIST) {
		$this_1.lastMouseOverVec = closePoint;
		$this_1.lastMouseOverPercent = $this_1.$self.getClosestPercent(x, y);
		return $this_1.$self;
		}
		return null;
		}
		$p.addMethod($this_1, 'getOverShape', getOverShape$2);
		function getPath$0() {
		return $this_1.$self;
		}
		$p.addMethod($this_1, 'getPath', getPath$0);
		function getPercent$1(p) {
		var index =  $this_1.$self.getIndex(p);
		return $this_1.$self.getLengthTo(index) / $this_1.$self.getlength();
		}
		$p.addMethod($this_1, 'getPercent', getPercent$1);
		function getPerpendicular$1(percent) {
		var vecBefore =  null;
		var vecAfter =  null;

		var offsetSearch =  .1;

		if (percent - offsetSearch < 0)
		vecBefore = $this_1.$self.getPos((percent));
		else
		vecBefore = $this_1.$self.getPos((percent - offsetSearch));

		if (percent + offsetSearch > 1)
		vecAfter = $this_1.$self.getPos((percent));
		else
		vecAfter = $this_1.$self.getPos((percent + offsetSearch));

		if (vecAfter == null)
		return null;

		vecAfter =  vecAfter.sub(vecBefore);
		vecAfter.normalize();

		if ($this_1.$self.WoundClockwise())
		vecAfter = vecAfter.rotate( Math.PI);

		return vecAfter;
		}
		$p.addMethod($this_1, 'getPerpendicular', getPerpendicular$1);
		function getPos$1(percent) {
		if (percent > 1 || percent < 0 || $this_1.l.size() < 1)
		return null;

		var totalLen =  $this_1.$self.getlength();
		var destLen =  totalLen * percent;

		var length =  0;
		var offset =  0;

		if (!$this_1.$self.getClosed())
		offset = 1;

		var lastMeasuredPoint =   $this_1.l.get(0);
		for (var i =  0;  i < $this_1.l.size() - offset;  i++) {
		var curP =  $this_1.l.get(i);
		var nextP =  null;
		if (i < $this_1.l.size() - 1)
		nextP = $this_1.l.get(i + 1);
		else
		nextP = $this_1.l.get(0);

		if (curP.containsBezier() || nextP.containsBezier()) {
		var bezStep =  $this_1.$self.getParentSketch().getSketchGlobals().BEZIER_DETAIL_CALCULATIONS;
		for (var t =  bezStep;  t < 1;  t += bezStep) {
		var x =  functions.bezierPoint(curP.x,
		curP.getControlPoint2().x,
		nextP.getControlPoint1().x, nextP.x, t);
		var y =  functions.bezierPoint(curP.y,
		curP.getControlPoint2().y,
		nextP.getControlPoint1().y, nextP.y, t);

		length += lastMeasuredPoint.distanceTo(new Vec2D(x, y));
		lastMeasuredPoint = new Vec2D(x, y);

		if (length >= destLen)
		return new SketchPoint(x, y);
		}
		} else {
		length += curP.distanceTo(nextP);
		lastMeasuredPoint = nextP.copy();

		if (length > destLen) {
		var segLen =  curP.distanceTo(nextP);
		var lastLen =  length - segLen;
		var curPos =  destLen - lastLen;
		var t =  curPos / segLen;

		var x =  curP.x + ((nextP.x - curP.x) * t);
		var y =  curP.y + ((nextP.y - curP.y) * t);

		return new SketchPoint(x, y);
		}
		}
		}

		return null;
		}
		$p.addMethod($this_1, 'getPos', getPos$1);
		function getPos$2_2(index, percent) {
		if (percent > 1 || percent < 0)
		return null;

		var curP =  $this_1.l.get(index);
		var nextP =  $this_1.l.get(index + 1);

		if (curP.containsBezier() || nextP.containsBezier()) {
		var bez1 =  curP;
		var bez2 =  nextP;

		if (curP.containsBezier()) {
		bez1 = curP.getControlPoint2();
		}

		if (nextP.containsBezier()) {
		bez2 = nextP.getControlPoint1();
		}

		var x =  functions.bezierPoint(curP.x, bez1.x, bez2.x, nextP.x,
		percent);
		var y =  functions.bezierPoint(curP.y, bez1.y, bez2.y, nextP.y,
		percent);

		return new Vec2D(x, y);
		} else {
		var x =  curP.x + ((nextP.x - curP.x) * percent);
		var y =  curP.y + ((nextP.y - curP.y) * percent);

		return new Vec2D(x, y);
		}
		}
		$p.addMethod($this_1, 'getPos', getPos$2_2);
		function getPosApprox$3(curP, nextP, percent) {
		if (percent > 1 || percent < 0)
		return null;
		if (curP.containsBezier() || nextP.containsBezier()) {
		var x =  functions.bezierPoint(curP.x, curP.getControlPoint2().x,
		nextP.getControlPoint1().x, nextP.x, percent);
		var y =  functions.bezierPoint(curP.y, curP.getControlPoint2().y,
		nextP.getControlPoint1().y, nextP.y, percent);
		return new SketchPoint(x, y);
		} else {
		var x =  curP.x + ((nextP.x - curP.x) * percent);
		var y =  curP.y + ((nextP.y - curP.y) * percent);
		return new SketchPoint(x, y);
		}
		}
		$p.addMethod($this_1, 'getPosApprox', getPosApprox$3);
		function getPosIndex$1(percent) {
		if (percent > 1 || percent < 0)
		return 0;

		var totalLen =  $this_1.$self.getlength();
		var destLen =  totalLen * percent;

		var offset =  0;

		if ($this_1.$self.getClosed())
		offset = 1;

		for (var i =  0;  i < $this_1.l.size() + offset;  i++) {
		if ($this_1.$self.getLengthBetween(0, i) > destLen)
		return i - 1;
		}

		return 0;
		}
		$p.addMethod($this_1, 'getPosIndex', getPosIndex$1);
		function getPosStep$1(step) {
		$this_1.lastStepPercent += step;

		var percent =  $this_1.lastStepPercent;

		if (percent > 1 || percent < 0)
		return null;

		var totalLen =  $this_1.$self.getlength();

		var destLen =  totalLen * percent;  
		var lengthToCurrentPos =  $this_1.lastStepLengthAlong;  
		var offset =  0;

		if (!$this_1.$self.getClosed())
		offset = 1;

		if ($this_1.lastStepMeasuredPoint == null && $this_1.l.size() > 0)
		$this_1.lastStepMeasuredPoint =  $this_1.l.get(0);

		for (var i =  $this_1.lastStepStartPos;  i < $this_1.l.size() - offset;  i++) {
		var curP =  $this_1.l.get(i);
		var nextP =  null;

		 if (i < $this_1.l.size() - 1)
		nextP = $this_1.l.get(i + 1);
		else
		nextP = $this_1.l.get(0);

		if (curP.containsBezier() || nextP.containsBezier()) {
		var bezStep =  $this_1.$self.getParentSketch().getSketchGlobals().BEZIER_DETAIL_CALCULATIONS;
		for (var t =  bezStep + $this_1.lastStepAlongBezier;  t < 1;  t += bezStep) {
		var x =  functions.bezierPoint(curP.x,
		curP.getControlPoint2().x,
		nextP.getControlPoint1().x, nextP.x, t);
		var y =  functions.bezierPoint(curP.y,
		curP.getControlPoint2().y,
		nextP.getControlPoint1().y, nextP.y, t);

		lengthToCurrentPos += $this_1.lastStepMeasuredPoint
		.distanceTo(new Vec2D(x, y));
		$this_1.lastStepMeasuredPoint = new Vec2D(x, y);

		if (lengthToCurrentPos > destLen) {
		$this_1.lastStepAlongBezier = t;
		$this_1.lastStepLengthAlong = lengthToCurrentPos;
		$this_1.lastStepStartPos = i;

		 return new SketchPoint(x, y);
		}
		}
		$this_1.lastStepAlongBezier = 0;
		} else {
		lengthToCurrentPos += curP.distanceTo(nextP);

		if (lengthToCurrentPos > destLen) {
		var segLen =  curP.distanceTo(nextP);
		var lastLen =  lengthToCurrentPos - segLen;
		var curPos =  destLen - lastLen;
		var t =  curPos / segLen;

		var x =  curP.x + ((nextP.x - curP.x) * t);
		var y =  curP.y + ((nextP.y - curP.y) * t);
		lengthToCurrentPos -= (segLen);
		$this_1.lastStepLengthAlong = lengthToCurrentPos;
		$this_1.lastStepStartPos = i;
		$this_1.lastStepMeasuredPoint = nextP.copy();

		return new SketchPoint(x, y);
		} else {

		}
		}

		$this_1.lastStepAlongBezier = 0;
		}

		return null;
		}
		$p.addMethod($this_1, 'getPosStep', getPosStep$1);
		function getPosStep$3_2(curP, nextP, step) {
		$this_1.lastStepPercent += step;
		var percent =  $this_1.lastStepPercent;

		if (percent > 1 || percent < 0)
		return null;

		if ($this_1.lastStepLenghtSegment == 0)
		$this_1.lastStepLenghtSegment = $this_1.$self.getLengthBetween($this_1.$self.getIndex(curP),
		$this_1.$self.getIndex(nextP));

		var totalLen =  $this_1.lastStepLenghtSegment;

		var destLen =  totalLen * percent;

		var length =  $this_1.lastStepLengthAlong;

		if ($this_1.lastStepMeasuredPoint == null)
		$this_1.lastStepMeasuredPoint =  curP.copy();

		if (curP.containsBezier() || nextP.containsBezier()) {
		var bezStep =  $this_1.$self.getParentSketch().getSketchGlobals().BEZIER_DETAIL_CALCULATIONS;
		for (var t =  $this_1.lastStepAlongBezier;  t <= 1;  t += bezStep) {
		var x =  functions.bezierPoint(curP.x,
		curP.getControlPoint2().x, nextP.getControlPoint1().x,
		nextP.x, t);
		var y =  functions.bezierPoint(curP.y,
		curP.getControlPoint2().y, nextP.getControlPoint1().y,
		nextP.y, t);

		length += $this_1.lastStepMeasuredPoint.distanceTo(new Vec2D(x, y));
		$this_1.lastStepMeasuredPoint = new Vec2D(x, y);

		if (length > destLen) {
		$this_1.lastStepAlongBezier = t;
		$this_1.lastStepLengthAlong = length;
		return new SketchPoint(x, y);
		}
		}
		} else {
		if (length > destLen) {
		var segLen =  curP.distanceTo(nextP);
		var lastLen =  length - segLen;
		var curPos =  destLen - lastLen;
		var t =  curPos / segLen;

		var x =  curP.x + ((nextP.x - curP.x) * t);
		var y =  curP.y + ((nextP.y - curP.y) * t);

		$this_1.lastStepLengthAlong = length;
		return new SketchPoint(x, y);
		} else {
		length += curP.distanceTo(nextP);
		$this_1.lastStepMeasuredPoint = nextP.copy();
		}
		}
		$this_1.lastStepAlongBezier = 0;  return null;
		}
		$p.addMethod($this_1, 'getPosStep', getPosStep$3_2);
		function getSketchPointpickBuffer$1(col) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);
		if (col == $this_1.$self.getColor(i + ($this_1.id * 100)))
		return curVec;
		}
		return null;
		}
		$p.addMethod($this_1, 'getSketchPointpickBuffer', getSketchPointpickBuffer$1);
		function getVec2DpickBuffer$1(col) {
		return null;
		}
		$p.addMethod($this_1, 'getVec2DpickBuffer', getVec2DpickBuffer$1);
		function getVectorLoop$0() {
		if ($this_1.l.size() < 2)
		return null;

		var loop =  new $p.ArrayList();
		var prevVec =  null;
		if (SETTINGS_SKETCH.build_collision_mesh_detailed) {
		var step =  SETTINGS_SKETCH.build_collision_mesh_res
		/ $this_1.$self.getlength();

		for (var t =  0;  t < 1;  t += step) {
		var v =  $this_1.$self.getPos(t);

		if (t != 0) {
		var nodeBetween =  $this_1.$self.getNodeBetween(t - step, t);
		if (nodeBetween != null) {
		loop.add(new Vector2D(nodeBetween.x, nodeBetween.y));
		}
		}

		if (prevVec == null || v.x != prevVec.x && v.y != prevVec.y
		&& v != null) {
		prevVec = v;
		loop.add(new Vector2D(v.x, v.y));
		}
		}
		} else {
		for (var i =  1;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);
		if (prevVec == null || v.x != prevVec.x && v.y != prevVec.y) {
		prevVec = v;
		loop.add(new Vector2D(v.x, v.y));
		}
		}
		}

		return loop;
		}
		$p.addMethod($this_1, 'getVectorLoop', getVectorLoop$0);
		function indexOf$1(vec) {
		return $this_1.l.indexOf(vec);
		}
		$p.addMethod($this_1, 'indexOf', indexOf$1);
		function insertPoint$1(closestPoint) {
		var index =  $this_1.$self.getPosIndex($this_1.$self.getClosestPercent(closestPoint.x,
		closestPoint.y));

		 $this_1.l.add(index + 1, closestPoint);
		}
		$p.addMethod($this_1, 'insertPoint', insertPoint$1);
		function intersects$1(path) {
		if ($this_1.$self.intersectsCount(path) > 0)
		return true;
		else
		return false;
		}
		$p.addMethod($this_1, 'intersects', intersects$1);
		function intersectsCount$1(path2) {
		var x1max =  $this_1.$self.getMaxX();
		var x1min =  $this_1.$self.getMinX();
		var y1max =  $this_1.$self.getMaxY();
		var y1min =  $this_1.$self.getMinY();

		var x2max =  path2.getMaxX();
		var x2min =  path2.getMinX();
		var y2max =  path2.getMaxY();
		var y2min =  path2.getMinY();

		if ((x1min < x2max) && (x1max > x2min) && (y1min < y2max)
		&& (y1max > y2min)

		) {
		return $this_1.$self.intersectsPath(path2);
		} else {
		return 0;
		}
		}
		$p.addMethod($this_1, 'intersectsCount', intersectsCount$1);
		function intersectsPath$1(otherPath) {
		var intersectCount =  0;

		var loop =  0;
		if ($this_1.$self.getClosed())
		loop = 1;

		var loop2 =  0;

		if (otherPath.getClosed())
		loop2 = 1;

		for (var i =  1;  i < $this_1.l.size() + loop;  i++) {
		var curVec =  null;
		var preVec =  null;

		 if (i == 1) {
		curVec = $this_1.l.get(0);
		}

		if (i >= 1)
		preVec = $this_1.l.get(i - 1);

		if (i == $this_1.l.size()) {
		curVec = $this_1.l.get(0);
		preVec = $this_1.l.get($this_1.l.size() - 1);
		} else {
		curVec = $this_1.l.get(i);
		}

		for (var i2 =  1;  i2 < otherPath.l.size() + loop2;  i2++) {
		var curVec2 =  null;
		var preVec2 =  null;

		 if (i2 == 1) {
		curVec2 = otherPath.l.get(0);
		}

		if (i2 >= 1)
		preVec2 = otherPath.l.get(i2 - 1);

		if (i2 == otherPath.l.size()) {
		curVec2 = otherPath.l.get(0);
		preVec2 = otherPath.l.get(otherPath.l.size() - 1);
		} else {
		curVec2 = otherPath.l.get(i2);
		}

		if (functions.intersect(curVec.x, curVec.y, preVec.x, preVec.y,
		curVec2.x, curVec2.y, preVec2.x, preVec2.y) == functions.DO_INTERSECT)
		intersectCount++;
		}
		}
		return intersectCount;
		}
		$p.addMethod($this_1, 'intersectsPath', intersectsPath$1);
		function isPointInside$1(p) {
		return $this_1.$self.pointInPolygon(p);
		}
		$p.addMethod($this_1, 'isPointInside', isPointInside$1);
		function mouseDragged$2(mouseX, mouseY) {
		var pointOnPlane =  new Vec2D(mouseX, mouseY);
		if (($this_1.$self.getParentSketch().getSketchTools().getCurrentTool() == SketchTools.SELECT_TOOL || $this_1.$self.getParentSketch()
		.getSketchTools().getCurrentTool() == SketchTools.SELECT_BEZIER_TOOL)
		&& $this_1.$self.getParentSketch().getSketchTools().getMouseButton() == SketchTools.MOUSE_LEFT) {
		for (var i =  0;  i < $this_1.$self.getSelectedNodes().size();  i++) {
		var o =  $this_1.$self.getSelectedNodes().get(i);

		if ($p.__instanceof(o , SketchPoint)) {
		var v =   o;
		if (v.containsBezier()) {
		var delta =  v.sub(pointOnPlane);

		v.controlPoint1.subSelf(delta);
		v.controlPoint2.subSelf(delta);
		}
		v.set(pointOnPlane.x, pointOnPlane.y);
		}

		 if ($p.__instanceof(o , Vec2D)) {
		var v =   o;
		v.x = pointOnPlane.x;
		v.y = pointOnPlane.y;

		 if ($this_1.$self.getParentSketch().getSketchTools().getCurrentTool() == SketchTools.SELECT_BEZIER_TOOL) {

		}
		}

		$this_1.$self.resetCachedVariables();
		}
		}
		}
		$p.addMethod($this_1, 'mouseDragged', mouseDragged$2);
		function mouseReleased$2(mouseX, mouseY) {

		}
		$p.addMethod($this_1, 'mouseReleased', mouseReleased$2);
		function movePoint$2(selectedVec, planePoint) {

		}
		$p.addMethod($this_1, 'movePoint', movePoint$2);
		function offset$0() {

		}
		$p.addMethod($this_1, 'offset', offset$0);
		function optimize$0() {

		}
		$p.addMethod($this_1, 'optimize', optimize$0);
		function pointInPolygon$1(p) {
		var crossings =  0;
		for (var i =  0;  i < $this_1.l.size() - 1;  i++) {
		var curVec =  $this_1.l.get(i);
		var nextVec =  $this_1.l.get(i + 1);
		var slope =  (nextVec.x - curVec.x) / (nextVec.y - curVec.y);
		var cond1 =  (curVec.y <= p.y) && (p.y < nextVec.y);
		var cond2 =  (nextVec.y <= p.y) && (p.y < curVec.y);
		var cond3 =  p.x < slope * (p.y - curVec.y) + curVec.x;
		if ((cond1 || cond2) && cond3)
		crossings++;
		}
		return (crossings % 2 != 0);
		}
		$p.addMethod($this_1, 'pointInPolygon', pointInPolygon$1);
		function remove$1(i) {
		$this_1.l.remove(i);
		$this_1.$self.resetCachedVariables();
		}
		$p.addMethod($this_1, 'remove', remove$1);
		function remove$1_2(point) {
		$this_1.l.remove(point);
		}
		$p.addMethod($this_1, 'remove', remove$1_2);
		function removeVertex$1(v) {
		if ($this_1.$self.getClosed() && $p.__contains($this_1.l,v))
		$this_1.l.remove(v);

		if ($this_1.l.size() == 0)
		$this_1.$self.destroy();
		}
		$p.addMethod($this_1, 'removeVertex', removeVertex$1);
		function render$1(g) {
		if (!$this_1.$self.getParentSketch().screenshot
		&& $this_1.$self.getParentSketch().getLayerSelected()) {
		g.fill(SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_COLOUR);
		g.strokeWeight(SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_WEIGHT);
		g.stroke(SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_SELECTED);
		} else {
		g.noStroke();
		 g.fill(SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_COLOUR);
		}
		


		 switch ($this_1.$self.getParentSketch().getRenderMode()) {
		case Sketch.RENDER_3D_PREVIW:

		if ($this_1.$self.getParentSketch().getLayerSelected())
		g.fill(SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_DIAGRAM_COLOUR);
		else
		g.fill(SETTINGS_SKETCH.SKETCHSHAPE_FILL_DIAGRAM_COLOUR);

		g.noStroke();

		if ($this_1.isOutline) {
		g.stroke(SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_DIAGRAM);
		g.strokeWeight(SETTINGS_SKETCH.SKETCHOUTLINE_PATH_WEIGHT_DIAGRAM
		* SETTINGS_SKETCH.PATH_WIDTH_ZOOM);
		g.noFill();
		}

		var outlineOffset2 =  0;
		if ($this_1.isOutline)
		outlineOffset2 = 0.1;

		$this_1.$self.renderFace(g);

		
		break;case Sketch.RENDER_3D_NORMAL: {
		var extrudeDepth =  10;//($this_1.$self.getParentSketch().getOnSketchPlane().thickness / 2)
		/// SETTINGS_SKETCH.scale;

		 if ($this_1.isOutline) {
		g.fill(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_SIDE_FILL_COLOUR);
		$this_1.$self.renderSide(g, extrudeDepth * 2);

		g.noFill();
		g.stroke(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_COLOUR);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_WEIGHT);

		g.pushMatrix();
		g.translate(0, 0, extrudeDepth
		+ SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET);
		$this_1.$self.renderFace(g);
		g.popMatrix();

		g.pushMatrix();
		g.translate(0, 0,
		-(extrudeDepth + SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET));
		$this_1.$self.renderFace(g);
		g.popMatrix();
		} else {
		g.fill(SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_FILL_COLOUR);

		g.pushMatrix();
		g.translate(0, 0, extrudeDepth);
		$this_1.$self.renderFace(g);
		g.popMatrix();

		g.pushMatrix();
		g.translate(0, 0, -(extrudeDepth));
		$this_1.$self.renderFace(g);
		g.popMatrix();
		}
		}

		break;case Sketch.RENDER_3D_EDITING_PLANES: {
		var extrudeDepth =  ($this_1.$self.getParentSketch().getOnSketchPlane().thickness / 2)
		/ SETTINGS_SKETCH.scale;
		var offsetSize =  0;

		if ($this_1.isOutline) {
		if ($this_1.$self.getParentSketch().getLayerSelected()) {
		g.fill(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_SELECTED);

		 if ($this_1.$self.getParentSketch().getRender3D())
		$this_1.$self.renderSide(g, extrudeDepth * 2);

		g.noFill();
		g.stroke(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_SELECTED);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_SELECTED);
		offsetSize = SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET;
		} else {
		if ($this_1.$self.getParentSketch().getRender3D()) {
		g.stroke(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_UNSELECTED);

		   g.noFill();
		} else {
		g.noFill();
		g.stroke(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_UNSELECTED);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_UNSELECTED);
		offsetSize = SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET;
		}
		}

		 if ($this_1.$self.getParentSketch().getRender3D()) {
		g.pushMatrix();
		g.translate(0, 0, extrudeDepth + offsetSize);
		$this_1.$self.renderFace(g);
		g.popMatrix();

		g.pushMatrix();
		g.translate(0, 0, -(extrudeDepth + offsetSize));
		$this_1.$self.renderFace(g);
		g.popMatrix();
		} else {
		g.pushMatrix();
		g.translate(0, 0, offsetSize);
		$this_1.$self.renderFace(g);
		g.popMatrix();
		}
		} else {
		if (!$this_1.$self.getParentSketch().getLayerSelected()
		&& $this_1.$self.getParentSketch().getRender3D())
		return;

		if ($this_1.$self.getParentSketch().getLayerSelected()) {
		if ($this_1.selected) {
		g.noFill();
		g.stroke(SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_SELECTED);
		g.strokeWeight(SETTINGS_SKETCH.SKETCHSHAPE_PATH_WEIGHT_SELECTED);
		offsetSize = SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET * 3;
		} else {
		g.fill(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_SELECTED);
		g.stroke(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_SELECTED);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_SELECTED);
		offsetSize = 0;
		}
		} else {
		if ($this_1.$self.getParentSketch().getRender3D()) {
		g.fill(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_UNSELECTED);
		g.noStroke();
		offsetSize = 0;
		} else {
		g.fill(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_UNSELECTED);
		g.stroke(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_UNSELECTED);
		g.strokeWeight(SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_UNSELECTED);
		offsetSize = 0;
		}
		}

		if ((SETTINGS_SKETCH.SLICEPLACE_RENDER_VOLUME)
		&& $this_1.$self.getParentSketch() != null
		&& $this_1.$self.getParentSketch().getOnSketchPlane().thickness > SETTINGS.MIN_RENDER_WIDTH) {
		if ($this_1.$self.getParentSketch().getRender3D()) {
		g.pushMatrix();
		g.translate(0, 0, extrudeDepth + offsetSize);
		$this_1.$self.renderFace(g);
		g.popMatrix();

		g.pushMatrix();
		g.translate(0, 0, -(extrudeDepth + offsetSize));
		$this_1.$self.renderFace(g);
		g.popMatrix();
		} else {
		g.pushMatrix();
		g.translate(0, 0, offsetSize);
		$this_1.$self.renderFace(g);
		g.popMatrix();
		}
		} else {
		g.pushMatrix();
		g.translate(0, 0, offsetSize);
		$this_1.$self.renderFace(g);
		g.popMatrix();
		}
		}

		if ($this_1.$self.getParentSketch().getLayerSelected()) {
		g.pushMatrix();
		g.translate(0, 0, extrudeDepth
		+ (SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET * 2));

		if ($this_1.editable
		&& !$this_1.$self.getParentSketch().getSketchGlobals().renderScreenshot
		&& $this_1.$self.getParentSketch().getSketchTools().getCurrentTool() == SketchTools.SELECT_BEZIER_TOOL) {
		if ($this_1.$self.getType() == SketchShape.TYPE_SPLINE)
		$this_1.$self.renderNodesSmoothedSpline(g);
		else
		$this_1.$self.renderNodes(g);
		}

		if (($this_1.editable && ($this_1.$self.getParentSketch().getSketchTools()
		.getCurrentTool() == SketchTools.SELECT_TOOL || $this_1.$self.getParentSketch()
		.getSketchTools().getCurrentTool() == SketchTools.SELECT_BEZIER_TOOL))
		&& !$this_1.$self.getParentSketch().getSketchGlobals().renderScreenshot) {
		if ($this_1.$self.getType() == SketchShape.TYPE_SPLINE)
		$this_1.$self.renderNodesSmoothedSpline(g);
		else
		$this_1.$self.renderNodesOutline(g);
		}

		g.popMatrix();
		}
		}
		break;case Sketch.RENDER_3D_DIAGRAM:
		var outlineOffset =  0;
		var extrudeDepth =  $this_1.$self.getParentSketch().getOnSketchPlane().thickness / 2;
		extrudeDepth /= SETTINGS_SKETCH.scale;

		g.fill(SETTINGS_SKETCH.SKETCHSHAPE_FILL_DIAGRAM_COLOUR);
		g.noStroke();

		if ($this_1.isOutline) {
		g.noStroke();
		g.fill(SETTINGS_SKETCH.SKETCHSHAPE_FILL_DIAGRAM_COLOUR);
		$this_1.$self.renderSide(g, extrudeDepth * 2);
		g.noFill();
		}

		if ($this_1.isOutline) {
		g.stroke(SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_DIAGRAM);
		g.strokeWeight(SETTINGS_SKETCH.SKETCHOUTLINE_PATH_WEIGHT_DIAGRAM
		* SETTINGS_SKETCH.PATH_WIDTH_ZOOM);
		g.noFill();
		}

		if ($this_1.isOutline)
		outlineOffset = SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET ;

		g.pushMatrix();
		g.translate(0, 0, extrudeDepth + outlineOffset);
		$this_1.$self.renderFace(g);
		g.popMatrix();

		g.pushMatrix();
		g.translate(0, 0, -(extrudeDepth + outlineOffset));
		$this_1.$self.renderFace(g);
		g.popMatrix();

		break;case Sketch.RENDER_EDIT_SELECT:

		break;
		}

		
		}
		$p.addMethod($this_1, 'render', render$1);
		function removeBeziers$0() {
		for (var i =  0;  i < $this_1.l.size() - 1;  i++) {
		var curVec =  $this_1.l.get(i);
		curVec.controlPoint1 = null;
		curVec.controlPoint2 = null;
		}
		}
		$p.addMethod($this_1, 'removeBeziers', removeBeziers$0);
		function renderFace$1(g) {
		
				 
				 
		g.beginShape();

		var loop =  0;
		if ($this_1.$self.getClosed())
		loop = 1;

		if (!$this_1.$self.getClosed())
		g.noFill();

		for (var i =  1;  i < $this_1.l.size() + loop;  i++) {
		var curVec =  null;
		var preVec =  null;

		 if (i == 1) {
		curVec = $this_1.l.get(0);
		g.vertex(curVec.x, curVec.y);
		}

		if (i >= 1)
		preVec = $this_1.l.get(i - 1);

		if (i == $this_1.l.size()) {
		curVec = $this_1.l.get(0);
		preVec = $this_1.l.get($this_1.l.size() - 1);
		} else {
		curVec = $this_1.l.get(i);
		}

		if (curVec.containsBezier() || preVec != null
		&& preVec.containsBezier()) {
		var c1 =   preVec;
		var c2 =   curVec;

		if (c1 == null)
		c1 = new SketchPoint(0, 0);

		if (preVec != null && preVec.containsBezier()) {
		c1 = preVec.getControlPoint2();
		}

		if (curVec.containsBezier()) {
		c2 = curVec.getControlPoint1();
		}

		if (c1 != null && c2 != null && curVec != null)
		g.bezierVertex(c1.x, c1.y, c2.x, c2.y, curVec.x, curVec.y);
		} else {
		if (SETTINGS_SKETCH.Draw_Curves) {
		g.curveVertex(curVec.x, curVec.y);
		} else {
		g.vertex(curVec.x, curVec.y);
		}
		}

		if (i == $this_1.l.size() - 1 || $this_1.l.size() == 1) {

		}
		}
		if ($this_1.$self.getClosed())
		g.endShape($p.PConstants.CLOSE);
		else
		g.endShape($p.PConstants.OPEN);

		if ($this_1.$self.getParentSketch().getSketchTools().getCurrentTool() == SketchTools.DRAW_PATH_TOOL
		&& !$this_1.$self.getClosed() && $this_1.selected && $this_1.$self.getLength() > 0) {
		var firstPoint =  $this_1.$self.get(0);
		var mousePos =  new Vec2D(
		$this_1.$self.getParentSketch().getSketchTools().mouseX,
		$this_1.$self.getParentSketch().getSketchTools().mouseY);

		if (firstPoint.distanceTo(mousePos) < SETTINGS_SKETCH.MIN_CLOSE_SHAPE_DIST)
		g.ellipse(firstPoint.x, firstPoint.y, 20, 20);
		}

	
		}
		$p.addMethod($this_1, 'renderFace', renderFace$1);
		function renderNodesSmoothedSpline$1(g) {
		var selectDia =  SETTINGS_SKETCH.select_dia
		* (1 / $this_1.$self.getParentSketch().getZOOM());

		if (selectDia > SETTINGS_SKETCH.select_dia * 1.5)
		selectDia = SETTINGS_SKETCH.select_dia;

		selectDia = selectDia / 2;

		 g.noFill();
		g.stroke(SETTINGS_SKETCH.CONTROL_POINT_STROKE_COLOUR);
		g.fill(SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR);

		var startVect =   $this_1.$self.get(0);
		if (startVect != null) {
		if (startVect.isOver) {
		g.ellipse(startVect.x, startVect.y, selectDia * 2.5,
		selectDia * 2.5);
		startVect.isOver = false;
		} else
		g.ellipse(startVect.x, startVect.y, selectDia * 1.5,
		selectDia * 1.5);
		}

		var endVect =   $this_1.$self.get($this_1.$self.size() - 1);
		if (endVect != null) {
		if (endVect.isOver) {
		g.ellipse(endVect.x, endVect.y, selectDia * 2.5,
		selectDia * 2.5);
		endVect.isOver = false;
		} else
		g.ellipse(endVect.x, endVect.y, selectDia * 1.5,
		selectDia * 1.5);
		}

		g.noFill();
		g.beginShape();
		g.strokeWeight(SETTINGS_SKETCH.CONTROL_SPLINE_WEIGHT);

		 for (var i =  1;  i < $this_1.$self.size() - 1;  i++) {
		var curVec =   $this_1.$self.get(i);
		if (curVec.isOver) {
		g.strokeWeight(SETTINGS_SKETCH.CONTROL_SPLINE_WEIGHT * 1.5);
		curVec.isOver = false;
		}
		}

		for (var i =  0;  i < $this_1.$self.size();  i++) {
		var curVec =   $this_1.$self.get(i);

		g.vertex(curVec.x, curVec.y);
		}
		g.endShape();

		g.noFill();
		}
		$p.addMethod($this_1, 'renderNodesSmoothedSpline', renderNodesSmoothedSpline$1);
		function renderNodes$1(g) {
		if ($this_1.$self.getParentSketch().getSketchTools().renderNodesFlag) {
		g.strokeWeight(1);
		 for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);

		g.strokeWeight(1);
		g.stroke(SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR);
		 g.fill(SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR);

		if (curVec.containsBezier()) {
		if (curVec.controlPoint1 != null) {
		g.line(curVec.x, curVec.y, curVec.controlPoint1.x,
		curVec.controlPoint1.y);
		g.ellipse(curVec.controlPoint1.x,
		curVec.controlPoint1.y, 3, 3);
		}
		if (curVec.controlPoint2 != null) {
		g.line(curVec.x, curVec.y, curVec.controlPoint2.x,
		curVec.controlPoint2.y);
		g.ellipse(curVec.controlPoint2.x,
		curVec.controlPoint2.y, 3, 3);
		}
		}

		if (curVec.isOver) {
		g.ellipse(curVec.x, curVec.y, 10, 10);
		curVec.isOver = false;
		}
		}
		}
		}
		$p.addMethod($this_1, 'renderNodes', renderNodes$1);
		function renderNodesOutline$1(g) {
		g.noStroke();
		var selectDia =  SETTINGS_SKETCH.select_dia
		* (1 / $this_1.$self.getParentSketch().getSketchGlobals().zoom);

		if (selectDia > SETTINGS_SKETCH.select_dia * 1.5)
		selectDia = SETTINGS_SKETCH.select_dia;

		selectDia = selectDia / 2;

		if (!$this_1.$self.getParentSketch().getSketchTools().mouseDown) {
		g.fill(SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR);

		  for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);

		g.fill(SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR);

		if ($p.__contains($this_1.$self.getSelectedNodes(),curVec))
		g.fill(SETTINGS_SKETCH.CONTROL_POINT_FILL_SELECTED_COLOUR);

		g.ellipse(curVec.x, curVec.y, selectDia, selectDia);

		if (curVec.isOver) {
		g.ellipse(curVec.x, curVec.y, selectDia * 1.5,
		selectDia * 1.5);
		curVec.isOver = false;
		}
		}
		}
		}
		$p.addMethod($this_1, 'renderNodesOutline', renderNodesOutline$1);
		function renderPickBuffer$1(g) {
		$this_1.$self.renderSilhouette(g);
		var fill =  g.fillColor;
		var extrudeDepth =  $this_1.$self.getParentSketch().getOnSketchPlane().thickness / 2;
		extrudeDepth /= SETTINGS_SKETCH.scale;
		$this_1.$self.renderSide(g, extrudeDepth * 2);
		}
		$p.addMethod($this_1, 'renderPickBuffer', renderPickBuffer$1);
		function renderSide$2(g, width) {
		var halfWidth =  width / 2;
		g.noStroke();
		g.beginShape($p.PConstants.TRIANGLES);
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curPoint =  null;
		var prevPoint =  null;

		curPoint = $this_1.l.get(i);

		if (i == 0)
		prevPoint = $this_1.l.get($this_1.l.size() - 1);
		else
		prevPoint = $this_1.l.get(i - 1);

		if (prevPoint.controlPoint2 != null
		|| curPoint.controlPoint1 != null) {
		var dist =  prevPoint.distanceTo(curPoint);
		var step =  SETTINGS_SKETCH.RENDER_PIXELS_PER_TRIANGLE_BEZIER
		/ dist;

		var prevX =  prevPoint.x;
		var prevY =  prevPoint.y;
		for (var t =  0;  t <= 1;  t += step) {
		var bx =  functions.bezierPoint(prevPoint.x,
		prevPoint.getControlPoint2().x,
		curPoint.getControlPoint1().x, curPoint.x, t);

		var by =  functions.bezierPoint(prevPoint.y,
		prevPoint.getControlPoint2().y,
		curPoint.getControlPoint1().y, curPoint.y, t);

		g.vertex(prevX, prevY, halfWidth);
		g.vertex(prevX, prevY, -halfWidth);
		g.vertex(bx, by, -halfWidth);

		g.vertex(bx, by, -halfWidth);
		g.vertex(bx, by, halfWidth);
		g.vertex(prevX, prevY, halfWidth);

		prevX = bx;
		prevY = by;
		}
		} else {
		g.vertex(prevPoint.x, prevPoint.y, halfWidth);
		g.vertex(prevPoint.x, prevPoint.y, -halfWidth);
		g.vertex(curPoint.x, curPoint.y, -halfWidth);

		g.vertex(curPoint.x, curPoint.y, -halfWidth);
		g.vertex(curPoint.x, curPoint.y, halfWidth);
		g.vertex(prevPoint.x, prevPoint.y, halfWidth);
		}
		}
		g.endShape($p.PConstants.CLOSE);
		}
		$p.addMethod($this_1, 'renderSide', renderSide$2);
		function renderSilhouette$1(g) {
		g.beginShape();

		for (var i =  1;  i < $this_1.l.size() + 1;  i++) {
		var curVec =  null;
		var preVec =  null;

		 if (i == 1) {
		curVec = $this_1.l.get(0);
		g.vertex(curVec.x, curVec.y);
		}

		if (i >= 1)
		preVec = $this_1.l.get(i - 1);

		if (i == $this_1.l.size()) {
		curVec = $this_1.l.get(0);
		preVec = $this_1.l.get($this_1.l.size() - 1);
		} else {
		curVec = $this_1.l.get(i);
		}

		if (curVec.containsBezier() || preVec != null
		&& preVec.containsBezier()) {
		var c1 =  preVec;
		var c2 =  curVec;

		if (c1 == null)
		c1 = new SketchPoint(0, 0);

		if (preVec != null && preVec.containsBezier()) {
		c1 = preVec.getControlPoint2();
		}

		if (curVec.containsBezier()) {
		c2 = curVec.getControlPoint1();
		}

		if (c1 != null && c2 != null && curVec != null)
		g.bezierVertex(c1.x, c1.y, c2.x, c2.y, curVec.x, curVec.y);
		} else {
		if (SETTINGS_SKETCH.Draw_Curves) {
		g.curveVertex(curVec.x, curVec.y);
		} else {
		g.vertex(curVec.x, curVec.y);
		}
		}
		}

		g.endShape();
		}
		$p.addMethod($this_1, 'renderSilhouette', renderSilhouette$1);
		function replace$1(objClone) {

		}
		$p.addMethod($this_1, 'replace', replace$1);
		function reset$0() {
		$this_1.l = new $p.ArrayList();
		}
		$p.addMethod($this_1, 'reset', reset$0);
		function resetCachedVariables$0() {
		$this_1.cachedLength = -1;
		$this_1.cachedGetMaxX = -1;
		$this_1.cachedGetMaxY = -1;
		$this_1.cachedGetMinX = -1;
		$this_1.cachedGetMinY = -1;
		}
		$p.addMethod($this_1, 'resetCachedVariables', resetCachedVariables$0);
		function resetPosStep$0() {
		$this_1.lastStepStartPos = 0;
		$this_1.lastStepPercent = 0;
		$this_1.lastStepLengthAlong = 0;
		$this_1.lastStepAlongBezier = 0;
		$this_1.lastStepMeasuredPoint = null;
		$this_1.lastStepLenghtSegment = 0;
		}
		$p.addMethod($this_1, 'resetPosStep', resetPosStep$0);
		function scale$2(scale, centre) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);

		LOGGER.info("-> s " + scale);

		LOGGER.info("-> 1 " + curVec.x);

		curVec.x += (curVec.x - centre.x) * scale;
		LOGGER.info("-> 2 " + curVec.x);

		LOGGER.info("");

		curVec.y += (curVec.y - centre.y) * scale;

		if (curVec.containsBezier()) {
		if (curVec.controlPoint1 != null) {
		curVec.controlPoint1.x += (curVec.controlPoint1.x - centre.x)
		* scale;
		curVec.controlPoint1.y += (curVec.controlPoint1.y - centre.y)
		* scale;
		}

		if (curVec.controlPoint2 != null) {
		curVec.controlPoint2.x += (curVec.controlPoint2.x - centre.x)
		* scale;
		curVec.controlPoint2.y += (curVec.controlPoint2.y - centre.y)
		* scale;
		}
		}
		}
		}
		$p.addMethod($this_1, 'scale', scale$2);
		function scale$1_2(scale) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);

		curVec.scaleSelf(scale);

		if (curVec.containsBezier()) {
		if (curVec.controlPoint1 != null) {
		curVec.controlPoint1.scaleSelf(scale);
		}

		if (curVec.controlPoint2 != null) {
		curVec.controlPoint2.scaleSelf(scale);
		}
		}
		}
		$this_1.$self.resetCachedVariables();
		}
		$p.addMethod($this_1, 'scale', scale$1_2);
		function rotate$1(r) {
		$this_1.$self.rotate(r, $this_1.$self.getCentre());
		}
		$p.addMethod($this_1, 'rotate', rotate$1);
		function rotate$2_2(r, centre) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);

		var v =  functions.rotate(curVec, centre, r);
		curVec.x = v.x;
		curVec.y = v.y;

		if (curVec.containsBezier()) {
		if (curVec.controlPoint1 != null) {
		curVec.controlPoint1 =  functions.rotate(
		curVec.controlPoint1, centre, r);
		}

		if (curVec.controlPoint2 != null) {
		curVec.controlPoint2 =  functions.rotate(
		curVec.controlPoint2, centre, r);
		}
		}
		}
		$this_1.$self.resetCachedVariables();
		}
		$p.addMethod($this_1, 'rotate', rotate$2_2);
		function translate$1(delta) {
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var curVec =  $this_1.l.get(i);
		curVec.x += delta.x;
		curVec.y += delta.y;

		if (curVec.containsBezier()) {
		if (curVec.controlPoint1 != null) {
		curVec.controlPoint1.x += delta.x;
		curVec.controlPoint1.y += delta.y;
		}

		if (curVec.controlPoint2 != null) {
		curVec.controlPoint2.x += delta.x;
		curVec.controlPoint2.y += delta.y;
		}
		}
		}
		$this_1.$self.resetCachedVariables();
		}
		$p.addMethod($this_1, 'translate', translate$1);
		function select$0() {
		$this_1.selected = true;
		}
		$p.addMethod($this_1, 'select', select$0);
		function selectNodes$2(mouseX, mouseY) {
		if ($this_1.$self.getParentSketch().getSketchTools().getCurrentTool() == SketchTools.SELECT_TOOL) {
		$this_1.$self.unselectNodes();
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);

		var selectDia =  SETTINGS_SKETCH.select_dia
		* (1 / $this_1.$self.getParentSketch().getSketchGlobals().zoom);

		if (selectDia > SETTINGS_SKETCH.select_dia * 1.5)
		selectDia = SETTINGS_SKETCH.select_dia;

		if (v.distanceTo(new SketchPoint(mouseX, mouseY)) < selectDia)
		$this_1.$self.getSelectedNodes().add(v);
		}
		}

		if ($this_1.$self.getParentSketch().getSketchTools().getCurrentTool() == SketchTools.SELECT_BEZIER_TOOL) {
		$this_1.$self.unselectNodes();
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);

		if (v.containsBezier()) {
		if (v.controlPoint1.distanceTo(new SketchPoint(mouseX,
		mouseY)) < SETTINGS_SKETCH.select_dia)
		$this_1.$self.getSelectedNodes().add(v.controlPoint1);

		if (v.controlPoint2.distanceTo(new SketchPoint(mouseX,
		mouseY)) < SETTINGS_SKETCH.select_dia)
		$this_1.$self.getSelectedNodes().add(v.controlPoint2);
		}

		if (v.distanceTo(new SketchPoint(mouseX, mouseY)) < SETTINGS_SKETCH.select_dia) {
		if (!v.containsBezier()) {
		$this_1.$self.addBezier(v, v.copy(),v.copy());

		 $this_1.$self.getSelectedNodes().add(v.controlPoint1);
		}
		}
		}
		}
		}
		$p.addMethod($this_1, 'selectNodes', selectNodes$2);
		function set$2(index, point) {
		$this_1.l.set(index, point);
		}
		$p.addMethod($this_1, 'set', set$2);
		function setPath$1(outline) {
		$this_1.l = outline;
		}
		$p.addMethod($this_1, 'setPath', setPath$1);
		function setSketchPointpickBuffer$5(col, selectedVec, selectedShape, selectedVecPlane, isSelectedVecOnOutline) {
		return null;
		}
		$p.addMethod($this_1, 'setSketchPointpickBuffer', setSketchPointpickBuffer$5);
		function setupSpShape$1(shape) {
		var loop =  new $p.ArrayList();
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);

		var point =  new SketchPoint(v.x, v.y);

		if (v.controlPoint1 != null) {
		point.controlPoint1 = new Vec2D(v.controlPoint1.x,
		v.controlPoint1.y);
		}

		if (v.controlPoint2 != null) {
		point.controlPoint2 = new Vec2D(v.controlPoint2.x,
		v.controlPoint2.y);
		}

		loop.add(point);
		}  
		shape.addOutline(loop);
		}
		$p.addMethod($this_1, 'setupSpShape', setupSpShape$1);
		function addCollisionToSpShape$1(shape) {
		var loop =  new $p.ArrayList();
		for (var i =  0;  i < $this_1.l.size();  i++) {
		var v =  $this_1.l.get(i);

		var point =  new SketchPoint(v.x, v.y);

		if (v.controlPoint1 != null) {
		point.controlPoint1 = new Vec2D(v.controlPoint1.x,
		v.controlPoint1.y);
		}

		if (v.controlPoint2 != null) {
		point.controlPoint2 = new Vec2D(v.controlPoint2.x,
		v.controlPoint2.y);
		}

		loop.add(point);
		}  
		shape.addCollisionOutline(loop);
		}
		$p.addMethod($this_1, 'addCollisionToSpShape', addCollisionToSpShape$1);
		function setVec2DpickBuffer$5(col, selectedVec, selectedShape, selectedVecPlane, isSelectedVecOnOutline) {
		return null;
		}
		$p.addMethod($this_1, 'setVec2DpickBuffer', setVec2DpickBuffer$5);
		function size$0() {
		return $this_1.l.size();
		}
		$p.addMethod($this_1, 'size', size$0);
		function smooth$1(scale) {
		if (!$this_1.$self.WoundClockwise())
		$this_1.$self.smoothLeft(scale);
		else
		$this_1.$self.smoothRight(scale);
		}
		$p.addMethod($this_1, 'smooth', smooth$1);
		function smoothLeft$1(scale) {
		if ($this_1.$self.size() < 2) {
		return;
		}

		if (!$this_1.$self.getClosed()) {
		for (var i =  0;  i < $this_1.$self.size();  i++) {
		if (i == 0)  {
		var p1 =  $this_1.$self.get(i);
		var p2 =  $this_1.$self.get(i + 1);
		var tangent =  p2.sub(p1);
		var q1 =  p1.add(tangent.scale(scale));
		p1.controlPoint1 = p1;
		p1.controlPoint2 = q1;
		} else if (i == $this_1.$self.size() - 1)  {
		var p0 =  $this_1.$self.get(i - 1);
		var p1 =  $this_1.$self.get(i);
		var tangent =  p1.sub(p0);
		var q0 =  p1.sub(tangent.scale(scale));

		p1.controlPoint1 = q0;
		p1.controlPoint2 = p1.copy();
		} else {
		var p0 = null,p1 = null,p2 = null;
		p0 = $this_1.$self.get(i - 1);
		p1 = $this_1.$self.get(i);
		p2 = $this_1.$self.get(i + 1);

		var tangent =  (p2.sub(p0)).normalize();
		var q0 =  p1.sub(tangent.scale(scale).scale(
		p1.sub(p0).magnitude()));
		var q1 =  p1.add(tangent.scale(scale).scale(
		p2.sub(p1).magnitude()));
		p1.controlPoint2 = q0;
		p1.controlPoint1 = q1;
		}
		}
		} else {
		for (var i =  0;  i < $this_1.$self.size();  i++) {
		var p0 = null,p1 = null,p2 = null;
		if (i > 0)
		p0 = $this_1.$self.get(i - 1);
		else
		p0 = $this_1.$self.get($this_1.$self.size() - 1);

		p1 = $this_1.$self.get(i);

		if (i < $this_1.$self.size() - 1)
		p2 = $this_1.$self.get(i + 1);
		else
		p2 = $this_1.$self.get(0);

		var tangent =  (p2.sub(p0)).normalize();
		var q0 =  p1.sub(tangent.scale(scale).scale(
		p1.sub(p0).magnitude()));
		var q1 =  p1.add(tangent.scale(scale).scale(
		p2.sub(p1).magnitude()));
		p1.controlPoint1 = q0;
		p1.controlPoint2 = q1;
		}
		}
		}
		$p.addMethod($this_1, 'smoothLeft', smoothLeft$1);
		function smoothRight$1(scale) {
		if ($this_1.$self.size() < 2) {
		return;
		}

		if (!$this_1.$self.getClosed()) {
		for (var i =  $this_1.$self.size() - 1;  i >= 0;  i--) {
		if (i == 0)  {
		var p1 =  $this_1.$self.get(i);
		var p2 =  $this_1.$self.get(i + 1);
		var tangent =  p2.sub(p1);
		var q1 =  p1.add(tangent.scale(scale));
		p1.controlPoint1 = p1;
		p1.controlPoint2 = q1;
		} else if (i == $this_1.$self.size() - 1)  {
		var p0 =  $this_1.$self.get(i - 1);
		var p1 =  $this_1.$self.get(i);
		var tangent =  p1.sub(p0);
		var q0 =  p1.sub(tangent.scale(scale));

		p1.controlPoint1 = q0;
		p1.controlPoint2 = p1.copy();
		} else {
		var p0 = null,p1 = null,p2 = null;
		p0 = $this_1.$self.get(i + 1);
		p1 = $this_1.$self.get(i);
		p2 = $this_1.$self.get(i - 1);

		var tangent =  (p2.sub(p0)).normalize();
		var q0 =  p1.sub(tangent.scale(scale).scale(
		p1.sub(p0).magnitude()));
		var q1 =  p1.add(tangent.scale(scale).scale(
		p2.sub(p1).magnitude()));
		p1.controlPoint2 = q0;
		p1.controlPoint1 = q1;
		}
		}
		} else {
		for (var i =  $this_1.$self.size() - 1;  i >= 0;  i--) {
		var p0 = null,p1 = null,p2 = null;
		if (i > 0)
		p0 = $this_1.$self.get(i - 1);
		else
		p0 = $this_1.$self.get($this_1.$self.size() - 1);

		p1 = $this_1.$self.get(i);

		if (i < $this_1.$self.size() - 1)
		p2 = $this_1.$self.get(i + 1);
		else
		p2 = $this_1.$self.get(0);

		var tangent =  (p2.sub(p0)).normalize();
		var q0 =  p1.sub(tangent.scale(scale).scale(
		p1.sub(p0).magnitude()));
		var q1 =  p1.add(tangent.scale(scale).scale(
		p2.sub(p1).magnitude()));
		p1.controlPoint1 = q0;
		p1.controlPoint2 = q1;
		}
		}
		}
		$p.addMethod($this_1, 'smoothRight', smoothRight$1);
		function toXML$0() {
		var element =  new Element("SketchPath");

		element.addAttribute(new Attribute("id", String.valueOf($this_1.$self.getId())));

		if ($this_1.isConstructionLine())
		element.addAttribute(new Attribute("isConstructionLine", "true"));

		if ($this_1.$self.getClosed())
		element.addAttribute(new Attribute("closed", "true"));
		else
		element.addAttribute(new Attribute("closed", "false"));

		element.addAttribute(new Attribute("isConstructionLine", "true"));

		element.addAttribute(new Attribute("union", String.valueOf($this_1.union)));

		for (var i =  0;  i < $this_1.l.size();  i++) {
		var point =  $this_1.l.get(i);
		element.appendChild(point.toXML());
		}
		return element;
		}
		$p.addMethod($this_1, 'toXML', toXML$0);
		function unselect$0() {
		$this_1.selected = false;
		}
		$p.addMethod($this_1, 'unselect', unselect$0);
		function update$0() {

		}
		$p.addMethod($this_1, 'update', update$0);
		function woudClockwiseReset$0() {
		$this_1.woundClockwiseReset = true;
		}
		$p.addMethod($this_1, 'woudClockwiseReset', woudClockwiseReset$0);
		function WoundClockwise$0() {
		if (!$this_1.woundClockwiseReset)
		return $this_1.woundClockwise;

		var area =  0;
		var offset =  1;

		if ($this_1.$self.getClosed())
		offset = 0;

		for (var i =  0;  i < $this_1.$self.size() - offset;  i++) {
		var p1 =  $this_1.$self.get(i);
		var p2 = null;

		if (i == $this_1.$self.size() - 1)
		p2 = $this_1.$self.get(0);
		else
		p2 = $this_1.$self.get(i + 1);

		area += (p1.x * p2.y) - (p2.x * p1.y);
		}

		if (area < 0)
		$this_1.woundClockwise = true;
		else
		$this_1.woundClockwise = false;

		$this_1.woundClockwiseReset = false;

		return $this_1.woundClockwise;
		}
		$p.addMethod($this_1, 'WoundClockwise', WoundClockwise$0);
		function reverseWinding$0() {
		Collections.reverse($this_1.l);
		}
		$p.addMethod($this_1, 'reverseWinding', reverseWinding$0);
		function renderFlat$1(g) {
		g.beginShape();

		var loop =  0;
		if ($this_1.$self.getClosed())
		loop = 1;

		for (var i =  1;  i < $this_1.l.size() + loop;  i++) {
		var curVec =  null;
		var preVec =  null;

		 if (i == 1) {
		curVec = $this_1.l.get(0);
		g.vertex(curVec.x, curVec.y);
		}

		if (i >= 1)
		preVec = $this_1.l.get(i - 1);

		if (i == $this_1.l.size()) {
		curVec = $this_1.l.get(0);
		preVec = $this_1.l.get($this_1.l.size() - 1);
		} else {
		curVec = $this_1.l.get(i);
		}

		if (curVec.containsBezier() || preVec != null
		&& preVec.containsBezier()) {
		var c1 =   preVec;
		var c2 =   curVec;

		if (c1 == null)
		c1 = new SketchPoint(0, 0);

		if (preVec != null && preVec.containsBezier()) {
		c1 = preVec.getControlPoint2();
		}

		if (curVec.containsBezier()) {
		c2 = curVec.getControlPoint1();
		}

		if (c1 != null && c2 != null && curVec != null) {
		g.bezierVertex(c1.x, c1.y, c2.x, c2.y, curVec.x, curVec.y);
		}
		} else {
		g.vertex(curVec.x, curVec.y);
		}
		}
		if ($this_1.$self.getClosed())
		g.endShape($p.PConstants.CLOSE);
		else
		g.endShape($p.PConstants.OPEN);
		}
		$p.addMethod($this_1, 'renderFlat', renderFlat$1);
		function removeOverlapping$1(tollerance) {
		var newPoints =  new $p.ArrayList();
		var lastAddedPoint =  null;
		for (var i =  0;  i < $this_1.l.size() - 1;  i++) {
		var curVec =  $this_1.l.get(i);

		if (lastAddedPoint == null
		|| lastAddedPoint.distanceTo(curVec) > tollerance) {
		newPoints.add(curVec);
		lastAddedPoint = curVec;
		}
		}

		$this_1.l = newPoints;
		}
		$p.addMethod($this_1, 'removeOverlapping', removeOverlapping$1);
		function flattenCurves$1(flatness) {
		var newPoints =  new $p.ArrayList();

		var loop =  1;
		if ($this_1.$self.getClosed())
		loop = 0;

		for (var i =  0;  i < $this_1.l.size() - loop;  i++) {
		var curVec =  $this_1.l.get(i);
		var nextVec =  null;
		if (i < $this_1.l.size() - 1)
		nextVec = $this_1.l.get(i + 1);
		else
		nextVec = $this_1.l.get(0);

		newPoints.add(curVec);

		if (curVec.containsBezier() || nextVec.containsBezier()) {
		var bez1 =  curVec;
		var bez2 =  nextVec;

		if (curVec.containsBezier()) {
		bez1 = curVec.getControlPoint2();
		}

		if (nextVec.containsBezier()) {
		bez2 = nextVec.getControlPoint1();
		}

		for (var t =  0;  t <= 1;  t += flatness) {
		var x =  functions.bezierPoint(curVec.x, bez1.x, bez2.x,
		nextVec.x, t);
		var y =  functions.bezierPoint(curVec.y, bez1.y, bez2.y,
		nextVec.y, t);

		newPoints.add(new SketchPoint(x, y));
		}
		}
		}

		$this_1.$self.removeBeziers();
		$this_1.l = newPoints;
		}
		$p.addMethod($this_1, 'flattenCurves', flattenCurves$1);
		function offsetPath$1(offset) {
		$this_1.$self.setClosed(true);
		$this_1.$self.flattenCurves(0.1);
		$this_1.$self.removeOverlapping(0.1);
		 var spline =  new SketchSpline($this_1.$self.getParentSketch());
		spline.setCentrePath($this_1.$self);
		spline.getCentrePath().setClosed(true);
		spline.joinType = SketchSpline.JOIN_BEVEL;
		spline.capType = SketchSpline.CAP_BUTT;
		spline.setOffsetSize(offset);
		spline.getParentSketch().getSketchGlobals().BEZIER_DETAIL_OFFSET = 0.01;
		spline.offset();
		var sLeft =  new SketchPath($this_1.$self.getParentSketch(),
		spline.outineLeft);
		 $this_1.l = sLeft.l;
		}
		$p.addMethod($this_1, 'offsetPath', offsetPath$1);
		function simplifyDouglasPeucker$1(epsilon) {
		LOGGER.info(" ");
		LOGGER.info(" ");

		$this_1.l = $this_1.$self.simplifyDouglasPeucker(
		functions.getRange($this_1.l, 0, $this_1.l.size() - 1), epsilon);
		}
		$p.addMethod($this_1, 'simplifyDouglasPeucker', simplifyDouglasPeucker$1);
		function simplifyDouglasPeucker$2_2(points, epsilon) {
		if (points.size() <= 1)
		return new $p.ArrayList();

		  var dmax =  0;
		var index =  0;

		for (var i =  1;  i < points.size() - 2;  i++) {
		var d =  SketchPath.PerpendicularDistance(points.get(0).copy(),
		points.get(points.size() - 1).copy(), points.get(i).copy());

		if (d > dmax) {
		index = i;
		dmax = d;
		}
		}
		var resultList =  new $p.ArrayList();
		 if (dmax >= epsilon) {
		var recResults1 =  $this_1.$self.simplifyDouglasPeucker(
		functions.getRange(points, 0, index), epsilon);
		var recResults2 =  $this_1.$self.simplifyDouglasPeucker(
		functions.getRange(points, index, points.size() - 1),
		epsilon);

		resultList.addAll(functions.getRange(recResults1, 0,
		recResults1.size() - 2));
		resultList.addAll(recResults2);
		} else {
		resultList.add( points.get(0).clone());
		resultList.add( points.get(points.size() - 1).clone());
		}

		 return resultList;
		}
		$p.addMethod($this_1, 'simplifyDouglasPeucker', simplifyDouglasPeucker$2_2);
		$p.addMethod($this_1, 'PerpendicularDistance', PerpendicularDistance$3);
		function $constr_2(offsetType, parentSketch){
		$superCstr(parentSketch);
		$this_1.offsetType = offsetType;
		}

		function $constr_1(parentSketch){
		$superCstr(parentSketch);
		}

		function $constr_2(parentSketch, outline){
		$superCstr(parentSketch);
		for (var i =  0;  i < outline.size();  i++) {
		var p =  outline.get(i);
		$this_1.$self.add(p);
		}
		}

		function $constr() {
		if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else if(arguments.length === 2) { $constr_2.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		$p.extendStaticMembers(SketchPath, SketchShape);
		SketchPath.OFFSET_LEFT =  0;
		SketchPath.OFFSET_RIGHT =  1;
		SketchPath.OFFSET_BOTH =  2;
		function PerpendicularDistance$3(Point1, Point2, Point) {
		var area =  Math
		.abs(.5 * (Point1.x * Point2.y + Point2.x * Point.y + Point.x
		* Point1.y - Point2.x * Point1.y - Point.x * Point2.y - Point1.x
		* Point.y));
		var bottom =  Math.sqrt(Math.pow(Point1.x - Point2.x, 2)
		+ Math.pow(Point1.y - Point2.y, 2));
		var height =  area / bottom * 2;

		return height;
		}
		$p.addMethod(SketchPath, 'PerpendicularDistance', PerpendicularDistance$3);
		SketchPath.$base = SketchShape;
		return SketchPath;
		})();
		$p.SketchPath = SketchPath;
		var SETTINGS_SKETCH = (function() {
		function SETTINGS_SKETCH() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$p.defineProperty($this_1, 'OUTLINE_COLOUR', {get: function(){return SETTINGS_SKETCH.OUTLINE_COLOUR}, set: function(val){SETTINGS_SKETCH.OUTLINE_COLOUR = val}});
		$p.defineProperty($this_1, 'FILL_COLOUR', {get: function(){return SETTINGS_SKETCH.FILL_COLOUR}, set: function(val){SETTINGS_SKETCH.FILL_COLOUR = val}});
		$p.defineProperty($this_1, 'EDGE_COLOUR', {get: function(){return SETTINGS_SKETCH.EDGE_COLOUR}, set: function(val){SETTINGS_SKETCH.EDGE_COLOUR = val}});
		$p.defineProperty($this_1, 'TRANSPARENT_COLOUR', {get: function(){return SETTINGS_SKETCH.TRANSPARENT_COLOUR}, set: function(val){SETTINGS_SKETCH.TRANSPARENT_COLOUR = val}});
		$p.defineProperty($this_1, 'UNSELECTED_FILL_COLOUR', {get: function(){return SETTINGS_SKETCH.UNSELECTED_FILL_COLOUR}, set: function(val){SETTINGS_SKETCH.UNSELECTED_FILL_COLOUR = val}});
		$p.defineProperty($this_1, 'UNSELECTED_SIDE_FILL_COLOUR', {get: function(){return SETTINGS_SKETCH.UNSELECTED_SIDE_FILL_COLOUR}, set: function(val){SETTINGS_SKETCH.UNSELECTED_SIDE_FILL_COLOUR = val}});
		$p.defineProperty($this_1, 'UNSELECTED_STROKE_COLOUR', {get: function(){return SETTINGS_SKETCH.UNSELECTED_STROKE_COLOUR}, set: function(val){SETTINGS_SKETCH.UNSELECTED_STROKE_COLOUR = val}});
		$p.defineProperty($this_1, 'HIGHLIGHT_COLOUR', {get: function(){return SETTINGS_SKETCH.HIGHLIGHT_COLOUR}, set: function(val){SETTINGS_SKETCH.HIGHLIGHT_COLOUR = val}});
		$p.defineProperty($this_1, 'RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_COLOUR', {get: function(){return SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_COLOUR}, set: function(val){SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_COLOUR = val}});
		$p.defineProperty($this_1, 'RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_WEIGHT', {get: function(){return SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_WEIGHT}, set: function(val){SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_WEIGHT = val}});
		$p.defineProperty($this_1, 'RENDER_3D_NORMAL_SKETCHSHAPE_SIDE_FILL_COLOUR', {get: function(){return SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_SIDE_FILL_COLOUR}, set: function(val){SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_SIDE_FILL_COLOUR = val}});
		$p.defineProperty($this_1, 'RENDER_3D_NORMAL_SKETCHSHAPE_FILL_COLOUR', {get: function(){return SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_FILL_COLOUR}, set: function(val){SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_FILL_COLOUR = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_SELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_SELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_SELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_SELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_SELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_SELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_SELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_SELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_SELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_UNSELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_UNSELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_UNSELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_UNSELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_UNSELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_UNSELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_UNSELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_UNSELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_UNSELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_UNSELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_UNSELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_UNSELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_SELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_SELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_SELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_SELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_SELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_SELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_SELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_SELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_SELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_UNSELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_UNSELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_UNSELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_UNSELECTED', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_UNSELECTED}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_UNSELECTED = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_COLOUR', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_COLOUR}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_COLOUR = val}});
		$p.defineProperty($this_1, 'RENDER_3D_EDITING_PLANES_WEIGHT', {get: function(){return SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_WEIGHT}, set: function(val){SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_WEIGHT = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_PATH_COLOUR_SELECTED', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_SELECTED}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_SELECTED = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_PATH_WEIGHT_SELECTED', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_PATH_WEIGHT_SELECTED}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_PATH_WEIGHT_SELECTED = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_PATH_COLOUR_UNSELECTED', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED = val}});
		$p.defineProperty($this_1, 'RED', {get: function(){return SETTINGS_SKETCH.RED}, set: function(val){SETTINGS_SKETCH.RED = val}});
		$p.defineProperty($this_1, 'sChair_unselected_line_colour', {get: function(){return SETTINGS_SKETCH.sChair_unselected_line_colour}, set: function(val){SETTINGS_SKETCH.sChair_unselected_line_colour = val}});
		$p.defineProperty($this_1, 'sChair_selected_line_colour', {get: function(){return SETTINGS_SKETCH.sChair_selected_line_colour}, set: function(val){SETTINGS_SKETCH.sChair_selected_line_colour = val}});
		$p.defineProperty($this_1, 'sChair_unselected_line_width', {get: function(){return SETTINGS_SKETCH.sChair_unselected_line_width}, set: function(val){SETTINGS_SKETCH.sChair_unselected_line_width = val}});
		$p.defineProperty($this_1, 'sChair_selected_line_width', {get: function(){return SETTINGS_SKETCH.sChair_selected_line_width}, set: function(val){SETTINGS_SKETCH.sChair_selected_line_width = val}});
		$p.defineProperty($this_1, 'dist_between_points', {get: function(){return SETTINGS_SKETCH.dist_between_points}, set: function(val){SETTINGS_SKETCH.dist_between_points = val}});
		$p.defineProperty($this_1, 'offset_size', {get: function(){return SETTINGS_SKETCH.offset_size}, set: function(val){SETTINGS_SKETCH.offset_size = val}});
		$p.defineProperty($this_1, 'select_on_path_step', {get: function(){return SETTINGS_SKETCH.select_on_path_step}, set: function(val){SETTINGS_SKETCH.select_on_path_step = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_STROKE_SELETEDSHAPE_COLOUR', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_STROKE_SELETEDSHAPE_COLOUR}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_STROKE_SELETEDSHAPE_COLOUR = val}});
		$p.defineProperty($this_1, 'CONTROL_POINT_FILL_COLOUR', {get: function(){return SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR}, set: function(val){SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR = val}});
		$p.defineProperty($this_1, 'CONTROL_POINT_FILL_SELECTED_COLOUR', {get: function(){return SETTINGS_SKETCH.CONTROL_POINT_FILL_SELECTED_COLOUR}, set: function(val){SETTINGS_SKETCH.CONTROL_POINT_FILL_SELECTED_COLOUR = val}});
		$p.defineProperty($this_1, 'CONTROL_POINT_STROKE_COLOUR', {get: function(){return SETTINGS_SKETCH.CONTROL_POINT_STROKE_COLOUR}, set: function(val){SETTINGS_SKETCH.CONTROL_POINT_STROKE_COLOUR = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_EDITING_SELECTED_WEIGHT', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_EDITING_SELECTED_WEIGHT}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_EDITING_SELECTED_WEIGHT = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_SELECTED_WEIGHT', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_SELECTED_WEIGHT}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_SELECTED_WEIGHT = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_UNSELECTED_WEIGHT', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_UNSELECTED_WEIGHT}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_UNSELECTED_WEIGHT = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_PATH_COLOUR_SELECTED', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_SELECTED}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_SELECTED = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_PATH_COLOUR_DIAGRAM', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_DIAGRAM}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_DIAGRAM = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_PATH_COLOUR_UNSELECTED', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_UNSELECTED}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_UNSELECTED = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_PATH_COLOUR_DEBUG', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_DEBUG}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_DEBUG = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_FILL_SELECTED', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_FILL_SELECTED}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_FILL_SELECTED = val}});
		$p.defineProperty($this_1, 'build_collision_mesh_detailed', {get: function(){return SETTINGS_SKETCH.build_collision_mesh_detailed}, set: function(val){SETTINGS_SKETCH.build_collision_mesh_detailed = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_FILL_UNSELECTED_LAYER_COLOUR', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_LAYER_COLOUR}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_LAYER_COLOUR = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_PATH_COLOUR_UNSELECTED_LAYER', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED_LAYER}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED_LAYER = val}});
		$p.defineProperty($this_1, 'Draw_Curve_Segments', {get: function(){return SETTINGS_SKETCH.Draw_Curve_Segments}, set: function(val){SETTINGS_SKETCH.Draw_Curve_Segments = val}});
		$p.defineProperty($this_1, 'Draw_Curves', {get: function(){return SETTINGS_SKETCH.Draw_Curves}, set: function(val){SETTINGS_SKETCH.Draw_Curves = val}});
		$p.defineProperty($this_1, 'calculate_based_on_curves', {get: function(){return SETTINGS_SKETCH.calculate_based_on_curves}, set: function(val){SETTINGS_SKETCH.calculate_based_on_curves = val}});
		$p.defineProperty($this_1, 'SLICEPLACE_RENDER_VOLUME', {get: function(){return SETTINGS_SKETCH.SLICEPLACE_RENDER_VOLUME}, set: function(val){SETTINGS_SKETCH.SLICEPLACE_RENDER_VOLUME = val}});
		$p.defineProperty($this_1, 'scale', {get: function(){return SETTINGS_SKETCH.scale}, set: function(val){SETTINGS_SKETCH.scale = val}});
		$p.defineProperty($this_1, 'select_dia', {get: function(){return SETTINGS_SKETCH.select_dia}, set: function(val){SETTINGS_SKETCH.select_dia = val}});
		$p.defineProperty($this_1, 'select_dia_touch', {get: function(){return SETTINGS_SKETCH.select_dia_touch}, set: function(val){SETTINGS_SKETCH.select_dia_touch = val}});
		$p.defineProperty($this_1, 'select_dia_default', {get: function(){return SETTINGS_SKETCH.select_dia_default}, set: function(val){SETTINGS_SKETCH.select_dia_default = val}});
		$p.defineProperty($this_1, 'build_collision_mesh_res', {get: function(){return SETTINGS_SKETCH.build_collision_mesh_res}, set: function(val){SETTINGS_SKETCH.build_collision_mesh_res = val}});
		$p.defineProperty($this_1, 'SELECT_EDGE_DIST', {get: function(){return SETTINGS_SKETCH.SELECT_EDGE_DIST}, set: function(val){SETTINGS_SKETCH.SELECT_EDGE_DIST = val}});
		$p.defineProperty($this_1, 'RENDER_PIXELS_PER_TRIANGLE_BEZIER', {get: function(){return SETTINGS_SKETCH.RENDER_PIXELS_PER_TRIANGLE_BEZIER}, set: function(val){SETTINGS_SKETCH.RENDER_PIXELS_PER_TRIANGLE_BEZIER = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_FILL_SELECTED_COLOUR', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_COLOUR}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_COLOUR = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_FILL_UNSELECTED_COLOUR', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_COLOUR}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_COLOUR = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_FILL_DIAGRAM_COLOUR', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_FILL_DIAGRAM_COLOUR}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_FILL_DIAGRAM_COLOUR = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_FILL_SELECTED_DIAGRAM_COLOUR', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_DIAGRAM_COLOUR}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_DIAGRAM_COLOUR = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_FILL_UNSELECTED_WEIGHT', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_WEIGHT}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_WEIGHT = val}});
		$p.defineProperty($this_1, 'SKETCHSHAPE_FILL_SELECTED_WEIGHT', {get: function(){return SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_WEIGHT}, set: function(val){SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_WEIGHT = val}});
		$p.defineProperty($this_1, 'slot_selected_fill_colour', {get: function(){return SETTINGS_SKETCH.slot_selected_fill_colour}, set: function(val){SETTINGS_SKETCH.slot_selected_fill_colour = val}});
		$p.defineProperty($this_1, 'slot_unselected_fill_colour', {get: function(){return SETTINGS_SKETCH.slot_unselected_fill_colour}, set: function(val){SETTINGS_SKETCH.slot_unselected_fill_colour = val}});
		$p.defineProperty($this_1, 'slat_selected_fill_colour', {get: function(){return SETTINGS_SKETCH.slat_selected_fill_colour}, set: function(val){SETTINGS_SKETCH.slat_selected_fill_colour = val}});
		$p.defineProperty($this_1, 'slat_unselected_fill_colour', {get: function(){return SETTINGS_SKETCH.slat_unselected_fill_colour}, set: function(val){SETTINGS_SKETCH.slat_unselected_fill_colour = val}});
		$p.defineProperty($this_1, 'render_outline', {get: function(){return SETTINGS_SKETCH.render_outline}, set: function(val){SETTINGS_SKETCH.render_outline = val}});
		$p.defineProperty($this_1, 'plane_thickness', {get: function(){return SETTINGS_SKETCH.plane_thickness}, set: function(val){SETTINGS_SKETCH.plane_thickness = val}});
		$p.defineProperty($this_1, 'plane_thickness_default', {get: function(){return SETTINGS_SKETCH.plane_thickness_default}, set: function(val){SETTINGS_SKETCH.plane_thickness_default = val}});
		$p.defineProperty($this_1, 'LEG_BRUSH_RATIO_TOP', {get: function(){return SETTINGS_SKETCH.LEG_BRUSH_RATIO_TOP}, set: function(val){SETTINGS_SKETCH.LEG_BRUSH_RATIO_TOP = val}});
		$p.defineProperty($this_1, 'LEG_BRUSH_RATIO_BOTTOM', {get: function(){return SETTINGS_SKETCH.LEG_BRUSH_RATIO_BOTTOM}, set: function(val){SETTINGS_SKETCH.LEG_BRUSH_RATIO_BOTTOM = val}});
		$p.defineProperty($this_1, 'BEZIER_DETAIL_EDIT', {get: function(){return SETTINGS_SKETCH.BEZIER_DETAIL_EDIT}, set: function(val){SETTINGS_SKETCH.BEZIER_DETAIL_EDIT = val}});
		$p.defineProperty($this_1, 'BEZIER_DETAIL_3D_PREVIEW', {get: function(){return SETTINGS_SKETCH.BEZIER_DETAIL_3D_PREVIEW}, set: function(val){SETTINGS_SKETCH.BEZIER_DETAIL_3D_PREVIEW = val}});
		$p.defineProperty($this_1, 'BEZIER_DETAIL_3D_DIAGRAM', {get: function(){return SETTINGS_SKETCH.BEZIER_DETAIL_3D_DIAGRAM}, set: function(val){SETTINGS_SKETCH.BEZIER_DETAIL_3D_DIAGRAM = val}});
		$p.defineProperty($this_1, 'MIN_CLOSE_SHAPE_DIST', {get: function(){return SETTINGS_SKETCH.MIN_CLOSE_SHAPE_DIST}, set: function(val){SETTINGS_SKETCH.MIN_CLOSE_SHAPE_DIST = val}});
		$p.defineProperty($this_1, 'BEZIER_DETAIL_OFFSET_PREVIEW', {get: function(){return SETTINGS_SKETCH.BEZIER_DETAIL_OFFSET_PREVIEW}, set: function(val){SETTINGS_SKETCH.BEZIER_DETAIL_OFFSET_PREVIEW = val}});
		$p.defineProperty($this_1, 'BEZIER_DETAIL_CALCULATIONS_PREVIEW', {get: function(){return SETTINGS_SKETCH.BEZIER_DETAIL_CALCULATIONS_PREVIEW}, set: function(val){SETTINGS_SKETCH.BEZIER_DETAIL_CALCULATIONS_PREVIEW = val}});
		$p.defineProperty($this_1, 'BEZIER_DETAIL_OFFSET_RENDER', {get: function(){return SETTINGS_SKETCH.BEZIER_DETAIL_OFFSET_RENDER}, set: function(val){SETTINGS_SKETCH.BEZIER_DETAIL_OFFSET_RENDER = val}});
		$p.defineProperty($this_1, 'SMOOTH_AMOUNT', {get: function(){return SETTINGS_SKETCH.SMOOTH_AMOUNT}, set: function(val){SETTINGS_SKETCH.SMOOTH_AMOUNT = val}});
		$p.defineProperty($this_1, 'SKETCHOUTLINE_PATH_WEIGHT_DIAGRAM', {get: function(){return SETTINGS_SKETCH.SKETCHOUTLINE_PATH_WEIGHT_DIAGRAM}, set: function(val){SETTINGS_SKETCH.SKETCHOUTLINE_PATH_WEIGHT_DIAGRAM = val}});
		$p.defineProperty($this_1, 'OUTLINE_RENDER_OFFSET', {get: function(){return SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET}, set: function(val){SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET = val}});
		$p.defineProperty($this_1, 'CONTROL_SPLINE_WEIGHT', {get: function(){return SETTINGS_SKETCH.CONTROL_SPLINE_WEIGHT}, set: function(val){SETTINGS_SKETCH.CONTROL_SPLINE_WEIGHT = val}});
		$p.defineProperty($this_1, 'BEZIER_DETAIL_CALCULATIONS_RENDER', {get: function(){return SETTINGS_SKETCH.BEZIER_DETAIL_CALCULATIONS_RENDER}, set: function(val){SETTINGS_SKETCH.BEZIER_DETAIL_CALCULATIONS_RENDER = val}});
		$p.defineProperty($this_1, 'offsetSide', {get: function(){return SETTINGS_SKETCH.offsetSide}, set: function(val){SETTINGS_SKETCH.offsetSide = val}});
		$p.defineProperty($this_1, 'crossSectionsConstrainedToShape', {get: function(){return SETTINGS_SKETCH.crossSectionsConstrainedToShape}, set: function(val){SETTINGS_SKETCH.crossSectionsConstrainedToShape = val}});
		$p.defineProperty($this_1, 'feltResolution', {get: function(){return SETTINGS_SKETCH.feltResolution}, set: function(val){SETTINGS_SKETCH.feltResolution = val}});
		$p.defineProperty($this_1, 'chair_slat_end_size', {get: function(){return SETTINGS_SKETCH.chair_slat_end_size}, set: function(val){SETTINGS_SKETCH.chair_slat_end_size = val}});
		$p.defineProperty($this_1, 'chair_width', {get: function(){return SETTINGS_SKETCH.chair_width}, set: function(val){SETTINGS_SKETCH.chair_width = val}});
		$p.defineProperty($this_1, 'spline_point_every', {get: function(){return SETTINGS_SKETCH.spline_point_every}, set: function(val){SETTINGS_SKETCH.spline_point_every = val}});
		$p.defineProperty($this_1, 'dist_between_adding_points', {get: function(){return SETTINGS_SKETCH.dist_between_adding_points}, set: function(val){SETTINGS_SKETCH.dist_between_adding_points = val}});
		$p.defineProperty($this_1, 'slat_x_spacing', {get: function(){return SETTINGS_SKETCH.slat_x_spacing}, set: function(val){SETTINGS_SKETCH.slat_x_spacing = val}});
		$p.defineProperty($this_1, 'slat_y_spacing', {get: function(){return SETTINGS_SKETCH.slat_y_spacing}, set: function(val){SETTINGS_SKETCH.slat_y_spacing = val}});
		$p.defineProperty($this_1, 'slat_spacing_x', {get: function(){return SETTINGS_SKETCH.slat_spacing_x}, set: function(val){SETTINGS_SKETCH.slat_spacing_x = val}});
		$p.defineProperty($this_1, 'fill_sketch', {get: function(){return SETTINGS_SKETCH.fill_sketch}, set: function(val){SETTINGS_SKETCH.fill_sketch = val}});
		$p.defineProperty($this_1, 'dynamic_offset', {get: function(){return SETTINGS_SKETCH.dynamic_offset}, set: function(val){SETTINGS_SKETCH.dynamic_offset = val}});
		$p.defineProperty($this_1, 'renderChairColour', {get: function(){return SETTINGS_SKETCH.renderChairColour}, set: function(val){SETTINGS_SKETCH.renderChairColour = val}});
		$p.defineProperty($this_1, 'PATH_WIDTH_ZOOM', {get: function(){return SETTINGS_SKETCH.PATH_WIDTH_ZOOM}, set: function(val){SETTINGS_SKETCH.PATH_WIDTH_ZOOM = val}});
		$p.defineProperty($this_1, 'splineMoveFalloff', {get: function(){return SETTINGS_SKETCH.splineMoveFalloff}, set: function(val){SETTINGS_SKETCH.splineMoveFalloff = val}});
		function $constr() {
		$superCstr();
		}
		$constr.apply(null, arguments);
		}
		SETTINGS_SKETCH.OUTLINE_COLOUR =  functions.color(30, 30,
		30);
		SETTINGS_SKETCH.FILL_COLOUR =  functions.color(255, 255,
		255);
		SETTINGS_SKETCH.EDGE_COLOUR =  functions.color(180, 180,
		180);
		SETTINGS_SKETCH.TRANSPARENT_COLOUR =  functions.color(255, 255,
		255,0);
		SETTINGS_SKETCH.UNSELECTED_FILL_COLOUR =  functions.color(255, 255,
		255,50);
		SETTINGS_SKETCH.UNSELECTED_SIDE_FILL_COLOUR =  functions.color(180, 180,
		180,50);
		SETTINGS_SKETCH.UNSELECTED_STROKE_COLOUR =  functions.color(120, 120,
		120,100);
		SETTINGS_SKETCH.HIGHLIGHT_COLOUR =  functions.color(0, 174,
		239);
		SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_COLOUR =  SETTINGS_SKETCH.OUTLINE_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHOUTLINE_STROKE_WEIGHT =  2.0;
		SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_SIDE_FILL_COLOUR =  SETTINGS_SKETCH.EDGE_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_NORMAL_SKETCHSHAPE_FILL_COLOUR =  SETTINGS_SKETCH.FILL_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_SELECTED =  SETTINGS_SKETCH.EDGE_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_SELECTED =  SETTINGS_SKETCH.OUTLINE_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_SELECTED =  3.0;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_SIDE_FILL_COLOUR_UNSELECTED =  SETTINGS_SKETCH.UNSELECTED_SIDE_FILL_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_COLOUR_UNSELECTED =  SETTINGS_SKETCH.UNSELECTED_STROKE_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_UNSELECTED =  SETTINGS_SKETCH.UNSELECTED_FILL_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHOUTLINE_STROKE_WEIGHT_UNSELECTED =  1.0;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_FILL_COLOUR_SELECTED =  SETTINGS_SKETCH.TRANSPARENT_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_SELECTED =  SETTINGS_SKETCH.OUTLINE_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_SELECTED =  1;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_COLOUR_UNSELECTED =  SETTINGS_SKETCH.TRANSPARENT_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_SKETCHSHAPE_STROKE_WEIGHT_UNSELECTED =  1;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_COLOUR =  SETTINGS_SKETCH.OUTLINE_COLOUR;
		SETTINGS_SKETCH.RENDER_3D_EDITING_PLANES_WEIGHT =  0.5;
		SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_SELECTED =  SETTINGS_SKETCH.HIGHLIGHT_COLOUR;
		SETTINGS_SKETCH.SKETCHSHAPE_PATH_WEIGHT_SELECTED =  3.0;
		SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED =  functions.color(100,
		100, 100);
		SETTINGS_SKETCH.RED =  functions.color(255, 0,
		0);
		SETTINGS_SKETCH.sChair_unselected_line_colour =  functions.color(30, 30,
		30);
		SETTINGS_SKETCH.sChair_selected_line_colour =  functions.color(250, 0, 0);
		SETTINGS_SKETCH.sChair_unselected_line_width =  1;
		SETTINGS_SKETCH.sChair_selected_line_width =  1;
		SETTINGS_SKETCH.dist_between_points =  100;
		SETTINGS_SKETCH.offset_size =  200;
		SETTINGS_SKETCH.select_on_path_step =  5.0;
		SETTINGS_SKETCH.SKETCHSHAPE_STROKE_SELETEDSHAPE_COLOUR =  functions
		.color(255, 30, 30);
		SETTINGS_SKETCH.CONTROL_POINT_FILL_COLOUR =  functions
		.color(0, 174, 239);
		SETTINGS_SKETCH.CONTROL_POINT_FILL_SELECTED_COLOUR =  functions.color(
		100, 174, 239);
		SETTINGS_SKETCH.CONTROL_POINT_STROKE_COLOUR =  functions.color(0, 174,
		239);
		SETTINGS_SKETCH.SKETCHOUTLINE_EDITING_SELECTED_WEIGHT =  1;
		SETTINGS_SKETCH.SKETCHOUTLINE_SELECTED_WEIGHT =  2;
		SETTINGS_SKETCH.SKETCHOUTLINE_UNSELECTED_WEIGHT =  2;
		SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_SELECTED =  functions.color(30,
		30, 30);
		SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_DIAGRAM =  functions.color(0,
		0, 0);
		SETTINGS_SKETCH.SKETCHOUTLINE_PATH_COLOUR_UNSELECTED =  functions.color(
		200, 200, 200);
		SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_DEBUG =  functions.color(
		255, 0, 0);
		SETTINGS_SKETCH.SKETCHOUTLINE_FILL_SELECTED =  false;
		SETTINGS_SKETCH.build_collision_mesh_detailed =  true;
		SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_LAYER_COLOUR =  functions
		.color(225, 225, 225);
		SETTINGS_SKETCH.SKETCHSHAPE_PATH_COLOUR_UNSELECTED_LAYER =  functions
		.color(200, 200, 200);
		SETTINGS_SKETCH.Draw_Curve_Segments =  false;
		SETTINGS_SKETCH.Draw_Curves =  false;
		SETTINGS_SKETCH.calculate_based_on_curves =  true;
		SETTINGS_SKETCH.SLICEPLACE_RENDER_VOLUME =  true;
		SETTINGS_SKETCH.scale =  .1;
		SETTINGS_SKETCH.select_dia =  20;
		SETTINGS_SKETCH.select_dia_touch =  40;
		SETTINGS_SKETCH.select_dia_default =  20;
		SETTINGS_SKETCH.build_collision_mesh_res =  50;
		SETTINGS_SKETCH.SELECT_EDGE_DIST =  10;
		SETTINGS_SKETCH.RENDER_PIXELS_PER_TRIANGLE_BEZIER =  3;
		SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_COLOUR =  functions.color(240,
		240, 240);
		SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_COLOUR =  functions.color(240,
		240, 240,50);
		SETTINGS_SKETCH.SKETCHSHAPE_FILL_DIAGRAM_COLOUR =  functions.color(255,
		255, 255);
		SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_DIAGRAM_COLOUR =  functions.color(0, 174,
		239);
		SETTINGS_SKETCH.SKETCHSHAPE_FILL_UNSELECTED_WEIGHT =  1;
		SETTINGS_SKETCH.SKETCHSHAPE_FILL_SELECTED_WEIGHT =  1;
		SETTINGS_SKETCH.slot_selected_fill_colour =  functions
		.color(255, 255, 255);
		SETTINGS_SKETCH.slot_unselected_fill_colour =  functions.color(255, 255,
		255);
		SETTINGS_SKETCH.slat_selected_fill_colour =  functions
		.color(255, 255, 255);
		SETTINGS_SKETCH.slat_unselected_fill_colour =  functions.color(255, 255,
		255);
		SETTINGS_SKETCH.render_outline =  true;
		SETTINGS_SKETCH.plane_thickness =  0.3;
		SETTINGS_SKETCH.plane_thickness_default =  0.3;
		SETTINGS_SKETCH.LEG_BRUSH_RATIO_TOP =  0.75;
		SETTINGS_SKETCH.LEG_BRUSH_RATIO_BOTTOM =  0.5;
		SETTINGS_SKETCH.BEZIER_DETAIL_EDIT =  20;
		SETTINGS_SKETCH.BEZIER_DETAIL_3D_PREVIEW =  10;
		SETTINGS_SKETCH.BEZIER_DETAIL_3D_DIAGRAM =  30;
		SETTINGS_SKETCH.MIN_CLOSE_SHAPE_DIST =  10;
		SETTINGS_SKETCH.BEZIER_DETAIL_OFFSET_PREVIEW =  0.05;
		SETTINGS_SKETCH.BEZIER_DETAIL_CALCULATIONS_PREVIEW =  0.01;
		SETTINGS_SKETCH.BEZIER_DETAIL_OFFSET_RENDER =  0.01;
		SETTINGS_SKETCH.SMOOTH_AMOUNT =  0.3;
		SETTINGS_SKETCH.SKETCHOUTLINE_PATH_WEIGHT_DIAGRAM =  2;
		SETTINGS_SKETCH.OUTLINE_RENDER_OFFSET =  1.0;
		SETTINGS_SKETCH.CONTROL_SPLINE_WEIGHT =  3;
		SETTINGS_SKETCH.BEZIER_DETAIL_CALCULATIONS_RENDER =  0.001;
		SETTINGS_SKETCH.offsetSide =  SketchSpline.OFFSET_BOTH;
		SETTINGS_SKETCH.crossSectionsConstrainedToShape =  true;
		SETTINGS_SKETCH.feltResolution =  .1;
		SETTINGS_SKETCH.chair_slat_end_size =  45;
		SETTINGS_SKETCH.chair_width =  400;
		SETTINGS_SKETCH.spline_point_every =  20;
		SETTINGS_SKETCH.dist_between_adding_points =  20;
		SETTINGS_SKETCH.slat_x_spacing =  250;
		SETTINGS_SKETCH.slat_y_spacing =  300;
		SETTINGS_SKETCH.slat_spacing_x =  39;
		SETTINGS_SKETCH.fill_sketch =  false;
		SETTINGS_SKETCH.dynamic_offset =  true;
		SETTINGS_SKETCH.renderChairColour =  functions.color(255, 255, 255);
		SETTINGS_SKETCH.PATH_WIDTH_ZOOM =  1.5;
		SETTINGS_SKETCH.splineMoveFalloff =  100;
		return SETTINGS_SKETCH;
		})();
		$p.SETTINGS_SKETCH = SETTINGS_SKETCH;
		var LOGGER = (function() {
		function LOGGER() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$p.addMethod($this_1, 'debug', debug$1);
		$p.addMethod($this_1, 'debug', debug$2_2);
		$p.addMethod($this_1, 'error', error$1);
		$p.addMethod($this_1, 'error', error$2_2);
		$p.addMethod($this_1, 'info', info$1);
		$p.addMethod($this_1, 'info', info$2_2);
		$p.addMethod($this_1, 'warn', warn$1);
		$p.addMethod($this_1, 'warn', warn$2_2);
		$p.addMethod($this_1, 'warning', warning$1);
		$p.addMethod($this_1, 'warning', warning$2_2);
		function $constr() {
		$superCstr();
		}
		$constr.apply(null, arguments);
		}
		function debug$1(message) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'debug', debug$1);
		function debug$2_2(message, obj) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'debug', debug$2_2);
		function error$1(message) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'error', error$1);
		function error$2_2(message, obj) {
		$p.println( message);
		}
		$p.addMethod(LOGGER, 'error', error$2_2);
		function info$1(message) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'info', info$1);
		function info$2_2(message, obj) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'info', info$2_2);
		function warn$1(message) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'warn', warn$1);
		function warn$2_2(message, obj) {
		$p.println(obj.getClass().getName() + ": " + message);
		}
		$p.addMethod(LOGGER, 'warn', warn$2_2);
		function warning$1(message) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'warning', warning$1);
		function warning$2_2(message, obj) {
		$p.println(message);
		}
		$p.addMethod(LOGGER, 'warning', warning$2_2);
		return LOGGER;
		})();
		$p.LOGGER = LOGGER;
		var SketchTools = (function() {
		function SketchTools() {
		var $this_1 = this;
		function $superCstr(){$p.extendClassChain($this_1)}
		$this_1.currentTool =  1;
		$this_1.brush_dia =  40;
		$this_1.mouseX = 0;
		$this_1.mouseY = 0;
		$this_1.keyCode = 0;
		$this_1.keyPressed = false;
		$this_1.renderNodesFlag =  true;
		$this_1.mouseDown = false;
		$this_1.pmouseX = 0;
		$this_1.pmouseY = 0;
		$this_1.mouseButton = 0;
		$this_1.key = null;
		$p.defineProperty($this_1, 'DRAW_TOOL', {get: function(){return SketchTools.DRAW_TOOL}, set: function(val){SketchTools.DRAW_TOOL = val}});
		$p.defineProperty($this_1, 'SELECT_TOOL', {get: function(){return SketchTools.SELECT_TOOL}, set: function(val){SketchTools.SELECT_TOOL = val}});
		$p.defineProperty($this_1, 'SELECT_BEZIER_TOOL', {get: function(){return SketchTools.SELECT_BEZIER_TOOL}, set: function(val){SketchTools.SELECT_BEZIER_TOOL = val}});
		$p.defineProperty($this_1, 'DRAW_PATH_TOOL', {get: function(){return SketchTools.DRAW_PATH_TOOL}, set: function(val){SketchTools.DRAW_PATH_TOOL = val}});
		$p.defineProperty($this_1, 'DRAW_OFFSETPATH_TOOL', {get: function(){return SketchTools.DRAW_OFFSETPATH_TOOL}, set: function(val){SketchTools.DRAW_OFFSETPATH_TOOL = val}});
		$p.defineProperty($this_1, 'MOVE_2D_TOOL', {get: function(){return SketchTools.MOVE_2D_TOOL}, set: function(val){SketchTools.MOVE_2D_TOOL = val}});
		$p.defineProperty($this_1, 'NONE', {get: function(){return SketchTools.NONE}, set: function(val){SketchTools.NONE = val}});
		$p.defineProperty($this_1, 'MOUSE_RIGHT', {get: function(){return SketchTools.MOUSE_RIGHT}, set: function(val){SketchTools.MOUSE_RIGHT = val}});
		$p.defineProperty($this_1, 'MOUSE_MIDDLE', {get: function(){return SketchTools.MOUSE_MIDDLE}, set: function(val){SketchTools.MOUSE_MIDDLE = val}});
		$p.defineProperty($this_1, 'MOUSE_LEFT', {get: function(){return SketchTools.MOUSE_LEFT}, set: function(val){SketchTools.MOUSE_LEFT = val}});
		$p.defineProperty($this_1, 'LEG_TOOL', {get: function(){return SketchTools.LEG_TOOL}, set: function(val){SketchTools.LEG_TOOL = val}});
		$this_1.zoom =  1;
		$this_1.currentCapType =  SketchSpline.CAP_ROUND;
		$p.defineProperty($this_1, 'DRAW_TOOL_CURSOR', {get: function(){return SketchTools.DRAW_TOOL_CURSOR}, set: function(val){SketchTools.DRAW_TOOL_CURSOR = val}});
		$p.defineProperty($this_1, 'SELECT_TOOL_CURSOR', {get: function(){return SketchTools.SELECT_TOOL_CURSOR}, set: function(val){SketchTools.SELECT_TOOL_CURSOR = val}});
		$p.defineProperty($this_1, 'ADD_DOLL_TOOL_CURSOR', {get: function(){return SketchTools.ADD_DOLL_TOOL_CURSOR}, set: function(val){SketchTools.ADD_DOLL_TOOL_CURSOR = val}});
		$p.defineProperty($this_1, 'MOVE_CAM_TOOL_CURSOR', {get: function(){return SketchTools.MOVE_CAM_TOOL_CURSOR}, set: function(val){SketchTools.MOVE_CAM_TOOL_CURSOR = val}});
		$p.defineProperty($this_1, 'MOVE_OBJECT_CURSOR', {get: function(){return SketchTools.MOVE_OBJECT_CURSOR}, set: function(val){SketchTools.MOVE_OBJECT_CURSOR = val}});
		$p.defineProperty($this_1, 'ROTATE_CAM_TOOL_CURSOR', {get: function(){return SketchTools.ROTATE_CAM_TOOL_CURSOR}, set: function(val){SketchTools.ROTATE_CAM_TOOL_CURSOR = val}});
		$p.defineProperty($this_1, 'ZOOM_CAM_TOOL_CURSOR', {get: function(){return SketchTools.ZOOM_CAM_TOOL_CURSOR}, set: function(val){SketchTools.ZOOM_CAM_TOOL_CURSOR = val}});
		$p.defineProperty($this_1, 'LINE_TOOL_CURSOR', {get: function(){return SketchTools.LINE_TOOL_CURSOR}, set: function(val){SketchTools.LINE_TOOL_CURSOR = val}});
		$p.defineProperty($this_1, 'SCALE_TOOL_CURSOR', {get: function(){return SketchTools.SCALE_TOOL_CURSOR}, set: function(val){SketchTools.SCALE_TOOL_CURSOR = val}});
		function build$1(applet) {
		SketchTools.DRAW_TOOL_CURSOR = applet.loadImage("gui/GUI_DRAW_TOOL_CURSOR.png");
		SketchTools.SELECT_TOOL_CURSOR = applet.loadImage("gui/GUI_SELECT_TOOL_CURSOR.png");
		SketchTools.LINE_TOOL_CURSOR = applet.loadImage("gui/GUI_LINE_TOOL_UP.png");
		SketchTools.SCALE_TOOL_CURSOR = applet.loadImage("gui/GUI_SCALE_TOOL_CURSOR.png");
		SketchTools.MOVE_OBJECT_CURSOR = applet
		.loadImage("gui/GUI_MOVE_CAM_TOOL_CURSOR.png");
		}
		$p.addMethod($this_1, 'build', build$1);
		function getCurrentCapType$0() {
		return $this_1.currentCapType;
		}
		$p.addMethod($this_1, 'getCurrentCapType', getCurrentCapType$0);
		function getCurrentTool$0() {
		return $this_1.currentTool;
		}
		$p.addMethod($this_1, 'getCurrentTool', getCurrentTool$0);
		function getMouseButton$0() {
		return $this_1.mouseButton;
		}
		$p.addMethod($this_1, 'getMouseButton', getMouseButton$0);
		function getPickBuffer$0() {
		return null;
		}
		$p.addMethod($this_1, 'getPickBuffer', getPickBuffer$0);
		function getPointOnPlane$2(vec2d, plane) {
		return null;
		}
		$p.addMethod($this_1, 'getPointOnPlane', getPointOnPlane$2);
		function getPointTranslated$1(mousePos) {
		return null;
		}
		$p.addMethod($this_1, 'getPointTranslated', getPointTranslated$1);
		function mouseDown$0() {

		}
		$p.addMethod($this_1, 'mouseDown', mouseDown$0);
		function mouseDragged$0() {

		}
		$p.addMethod($this_1, 'mouseDragged', mouseDragged$0);
		function mousePressed$0() {

		}
		$p.addMethod($this_1, 'mousePressed', mousePressed$0);
		function mouseReleased$0() {

		}
		$p.addMethod($this_1, 'mouseReleased', mouseReleased$0);
		function render$1(g) {
		$this_1.$self.renderPointer(g);
		}
		$p.addMethod($this_1, 'render', render$1);
		function renderPointer$1(g) {
		if ($this_1.$self.getCurrentTool() == SketchTools.DRAW_TOOL) {
		g.noFill();
		g.stroke(100, 100, 100);
		g.image(SketchTools.DRAW_TOOL_CURSOR, $this_1.mouseX - 5, $this_1.mouseY - 25);
		} else if ($this_1.$self.getCurrentTool() == SketchTools.LEG_TOOL) {
		g.image(SketchTools.DRAW_TOOL_CURSOR, $this_1.mouseX - 5, $this_1.mouseY - 25);
		} else if ($this_1.$self.getCurrentTool() == SketchTools.SELECT_TOOL) {
		g.image(SketchTools.SELECT_TOOL_CURSOR, $this_1.mouseX - 10, $this_1.mouseY - 8);
		} else if ($this_1.$self.getCurrentTool() == SketchTools.MOVE_2D_TOOL) {
		g.image(SketchTools.MOVE_CAM_TOOL_CURSOR, $this_1.mouseX - 10, $this_1.mouseY - 8);
		} else {
		g.image(SketchTools.SELECT_TOOL_CURSOR, $this_1.mouseX - 11, $this_1.mouseY - 7);
		}

		if ($this_1.$self.getCurrentTool() == SketchTools.DRAW_TOOL
		|| $this_1.$self.getCurrentTool() == SketchTools.DRAW_OFFSETPATH_TOOL) {
		g.ellipseMode(PApplet.CENTER);
		g.noFill();
		g.stroke(100, 100, 100);
		g.ellipse($this_1.mouseX, $this_1.mouseY, ($this_1.brush_dia * $this_1.zoom) * 2,
		($this_1.brush_dia * $this_1.zoom) * 2);
		}
		}
		$p.addMethod($this_1, 'renderPointer', renderPointer$1);
		function selectCap$1(e) {
		$this_1.currentCapType =  $p.__int_cast(e.getVal());
		}
		$p.addMethod($this_1, 'selectCap', selectCap$1);
		function getCap$0() {
		return $this_1.currentCapType;
		}
		$p.addMethod($this_1, 'getCap', getCap$0);
		function selectTool$1(e) {
		LOGGER.error("Selecting tool: " +  $p.__int_cast(e.val));
		$this_1.$self.selectTool( $p.__int_cast(e.val));
		}
		$p.addMethod($this_1, 'selectTool', selectTool$1);
		function selectTool$1_2(currentTool) {
		$this_1.currentTool = currentTool;
		}
		$p.addMethod($this_1, 'selectTool', selectTool$1_2);
		function toggleUnion$1(e) {
		$this_1.currentCapType =  $p.__int_cast(e.getVal());
		}
		$p.addMethod($this_1, 'toggleUnion', toggleUnion$1);
		function updateMouse$6(mouseX2, mouseY2, pmouseX2, pmouseY2, mouseDown2, mouseButton2) {
		$this_1.pmouseX = $this_1.mouseX;
		$this_1.pmouseY = $this_1.mouseY;

		$this_1.mouseX = mouseX2;
		$this_1.mouseY = mouseY2;

		$this_1.mouseDown = mouseDown2;
		$this_1.mouseButton = mouseButton2;
		}
		$p.addMethod($this_1, 'updateMouse', updateMouse$6);
		function $constr_1(applet){
		$superCstr();

		$this_1.$self.build(applet);
		}

		function $constr() {
		if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else $superCstr();
		}
		$constr.apply(null, arguments);
		}
		SketchTools.DRAW_TOOL =  1;
		SketchTools.SELECT_TOOL =  2;
		SketchTools.SELECT_BEZIER_TOOL =  9;
		SketchTools.DRAW_PATH_TOOL =  234;
		SketchTools.DRAW_OFFSETPATH_TOOL =  235;
		SketchTools.MOVE_2D_TOOL =  0;
		SketchTools.NONE =  -1;
		SketchTools.MOUSE_RIGHT =  39;
		SketchTools.MOUSE_MIDDLE =  3;
		SketchTools.MOUSE_LEFT =  37;
		SketchTools.LEG_TOOL =  7;
		SketchTools.DRAW_TOOL_CURSOR =  null;
		SketchTools.SELECT_TOOL_CURSOR =  null;
		SketchTools.ADD_DOLL_TOOL_CURSOR =  null;
		SketchTools.MOVE_CAM_TOOL_CURSOR =  null;
		SketchTools.MOVE_OBJECT_CURSOR =  null;
		SketchTools.ROTATE_CAM_TOOL_CURSOR = null;
		SketchTools.ZOOM_CAM_TOOL_CURSOR = null;
		SketchTools.LINE_TOOL_CURSOR = null;
		SketchTools.SCALE_TOOL_CURSOR = null;
		return SketchTools;
		})();
		$p.SketchTools = SketchTools;

		 var sketch = null;
		var g =  $p.createGraphics(600, 600,$p.P2D);
		var l =  new $p.ArrayList();

		var mouseDown =  false;
		var test =  new Test();
		function draw() {
		sketch.getSketchTools().updateMouse($p.mouseX,$p.mouseY,$p.pmouseX,$p.pmouseY,mouseDown,$p.mouseButton);

		$p.background(255,0,0);

	//	sketch.update();

		if ($p.__mousePressed && ($p.mouseX != $p.pmouseX || $p.mouseY != $p.pmouseY))
		sketch.mouseDragged($p.mouseX, $p.mouseY);

		if (!$p.__mousePressed && mouseDown){
			sketch.mouseReleased($p.mouseX, $p.mouseY);
			console.log(sketch);
			
		}

		if ($p.__mousePressed && !mouseDown)
		sketch.mousePressed($p.mouseX, $p.mouseY);

		if ($p.__mousePressed)
		mouseDown = true;
		else
		mouseDown = false;

		//sketch.render(g);
		sketch.update();
		sketch.sketchShapes.render($p);
		
		
		// $p.image(g,0,0);
		}
		$p.draw = draw;

		function setup() {
		$p.size(600, 600);
		sketch = new Sketch(this);
		sketch.sketchTools = new SketchTools(this);
		sketch.setRenderMode(Sketch.RENDER_3D_NORMAL);
		}
		$p.setup = setup;

		})
//--></script>


<canvas width="200" height="200" id="canvas1"></canvas>

<script type="text/javascript">
<!--


var canvas = document.getElementById("canvas1");
// attaching the sketchProc function to the canvas
var processingInstance = new Processing(canvas, mySketch);

//--></script>